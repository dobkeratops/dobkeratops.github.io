<html>
<body>
<style>body{overflow:hidden; width:100%;height:100%}</style>
<div>
tool:
<button id="point">(o)point</button>
<button id="line">(l)line</button>
<button id="rect">(r)rectangle</button>
<button id="poly">(p)polygon</button>
<button id="adjust">(a)adjust</button>
<input id="currentLabel" value="object">current label</button>
<input type="checkbox" id="showLabels" checked>showLabels</input>
<input type="checkbox" id="showAllPolys" checked>showAllPolys</input>
<button id="newImage">new image</button>
<button id="load">load</button>
<button id="save">save</button>
<button id="help">help</button>
<button id="prefs">prefs</button>

<div id="presetArea">
<canvas id="editor" width="1920" height="1080">
</canvas>
<script>

document.getElementById("help").onclick=function(){alert(
"hotkeys:\no\tpoint tool\nl\tline tool\nr\trect tool\np\tpoint tool\na\tadjust tool\n[ ]\ttoggle preset labels;\nenter\trename object;\n< >\tswitch current poly\n"+
"delete\tdelete polys or vertices\n"+
"save\tdownloads current annotations as JSON\n"+
"drag-drop JSON file to load image & annotations\n"+
"drag drop image URL to begin annotating an image\n"+
"\n"+
"Advanced:-\n"+
"shift\tMulti-select\n"+
"s\tSubdivide edges/polys\n"+
"ctrl-m\tMerge vertices\n"+
"shift-s\tseperate merged vertices\n"+
"e\textrude tool\n");
};
document.getElementById("prefs").onclick=function(){
   if (g_labelColor=="white") { g_labelColor="black";} else {g_labelColor="white";}
}
document.getElementById("newImage").onclick=function(){
/* confirm overwrite.. shouldn't need when web based.
  if (g_polys.length) {
    if (!confirm("changing URL will lose current polys:"+g_polys.length)){
      return;
    }
  }
*/
  url=prompt("enter image URL");
  if (!url){return;}
  
  LoadImage(url);
  g_polys=[];
  repaint();
}
var g_shift,g_ctrl,g_alt,g_leftmousebutton,g_rightmousebutton,g_midmousebutton;
editor=document.getElementById("editor");
var g_presetLabels=["object","person","vehicle","plant","animal","tree","building","machine","head","kerb","road marking","barrier","lamppost","bin","window","door","object1","object2","object3"];

labelEdit=document.getElementById("currentLabel");
//? only got dropdown, not combo boxes?
//throw the presets into the dropdown..
//for (i=0; i<g_presetLabels; i++) {
//
//}

var g_defaultColors={
   "person":"#1000f0", "people":"#1000f0", 
   "man":"#0000ff",    "woman":"#2000f0",
   "vehicle":"#ff0000", "car":"#ff0000",
   "bus":"#ff0000",     "truck":"#ff0000",
   "SUV":"#ff0000",     "suv":"#ff0000",
   "plant":"#00ff00",   "bush":"#00ff00",
   "vegetation":"#00ff00", "grass":"#00ff00",
   "tree":"#00ff00",
   "animal":"#800080",   "dog":"#800080",
   "horse":"#800080",    "cat":"#800080",
   "cow":"#800080",      "sheep":"#800080",
   "livestock":"#800080","cattle":"#800080",
   "building":"#c04000", "house":"#c04000",
   "barrier":"#c04000",
   "machine":"#008080",
};
var g_randomColors=[
  "#8000c0","#c08000","#80c000",
  "#0080c0","#c00080","#00c080",
];
function AddPoly(poly){ clr=g_defaultColors[poly.name]; if (clr){poly.color=clr;} else {poly.color=g_randomColors[g_polys.length % g_randomColors.length]}; g_polys.push(poly); g_currentPoly=g_polys.length-1;}
var g_currentPoly=-1;
var g_drawingPoly=[];
var g_presetLabelIndex=0;
var g_showLabelNames=true;
var g_showAllPolys=true;
var g_currentPolyOutline="#ffffff";
var g_promptSevereTools=true;
var g_shiftIsMultiSelect=true;
var g_mousepos={};
var g_dragstart={};
var g_drawfeedback=null;
var g_polys=[];
var g_tool;
var g_img = new window.Image();
var g_mouseDelta={x:0,y:0};
var g_showVertices=true;
var g_labelColor="white"
// default image to load..
g_img.src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Queen_Street_NOTL_1.jpg/1920px-Queen_Street_NOTL_1.jpg";
g_img.ready=false;

g_img.onload=function(){
  console.log("image.onload");
  g_scaled_w = 1024; g_scaled_h= (g_scaled_w * g_img.height)/g_img.width;
  this.ready=true;
  repaint();  
}

function LoadImage(url){
  //TODO: means of using pre-specified scaled sizes.
  g_img.ready=false;
  g_img.src=url;
  console.log("image.src="+url);
}

urlgadget=document.getElementById("imageurl");
if (urlgadget){
  urlgadget.oninput=function(){
    LoadImage(document.getElementById("imageurl").value);
    g_polys=[];
  } 
}
// mini maths lib
function vaddto(lhs,rhs){lhs.x+=rhs.x;lhs.y+=rhs.y;}
function vadd(lhs,rhs){return {x:lhs.x+rhs.x, y:lhs.y+rhs.y};}
function vsub(lhs,rhs){return {x:lhs.x-rhs.x, y:lhs.y-rhs.y};}
function lerp(a,b,f){return (b-a)*f+a;}
function vlerp(a,b,f){
	return {x:lerp(a.x,b.x,f), y:lerp(a.y,b.y,f)};
}
function vzero(){return {x:0,y:0}}
function vmadd(a,b,f){
	return {x:a.x+b.x*f,y:a.y+b.y*f}
}
function vscale(a,f){return {x:a.x*f,y:a.y*f}};
function vmulElem(a,b){return {x:a.x*b.x,y:a.y*b.y}};
function vdot(a,b){return a.x*b.x+a.y*b.y;}
function vcross2d(a,b){return a.x*b.y-a.y*b.x;}


var g_width = editor.width;
var g_height = editor.height;
var g_scaled_w = 1024; g_scaled_h= (g_scaled_w * g_img.height)/g_img.width;

function lerp(a,b,f){
   return (b-a)*f+a;
}
function polyDiagonalHexFromRect(rc) {
  var width = Math.abs(rc.end.x-rc.start.x);
  var height = Math.abs(rc.end.y-rc.start.y);
  x0 = rc.start.x;
  y0 = rc.start.y;
  x1 = rc.end.x;
  y1 = rc.end.y;
  fx=0.75; fy=0.125; // trim a little from the diagonal
  fyy=0.035;

  if (width > height) { // wider than tall - split horiz
     return {
      points:[
        {x:x0, y:lerp(y0,y1,fyy)},
        {x:lerp(x0,x1,fx),       y:y0},
        {x:x1,   y:lerp(y0,y1,fy)},
        {x:x1,   y:lerp(y1,y0,fyy)},
        {x:lerp(x1,x0,fx),       y:y1},
        {x:x0,   y:lerp(y1,y0,fy)}
      ],
      name:rc.name
     };
  } else {
     midy=(rc.start.y+rc.end.y)*0.5;
     return {
      points:[
        {x:lerp(x0,x1,fyy),     y:y0},
        {x:lerp(x1,x0,fy),     y:y0},
        {x:x1,     y:lerp(y0,y1,fy)},
        {x:lerp(x1,x0,fyy),     y:y1},
        {x:lerp(x0,x1,fy),  y:y1},
        {x:x0,      y:lerp(y1,y0,fy)}
      ],
      name:rc.name
    };
  }
}

function polyFromRect(rc) {
  return {
    points:[
      {x:rc.start.x, y:rc.start.y},
      {x:rc.end.x,   y:rc.start.y},
      {x:rc.end.x,   y:rc.end.y},
      {x:rc.start.x, y:rc.end.y}
    ],
    name:rc.name
  };
}

function polyOctFromRect(rc) {
  x0 = rc.start.x;
  y0 = rc.start.y;
  x1 = rc.end.x;
  y1 = rc.end.y;
  t=0.1; // trim a little from the corners

  return {
    points:[
      {x:lerp(x0,x1,t),  y:y0},
      {x:lerp(x1,x0,t),  y:y0},
      {x:x1,  y:lerp(y0,y1,t)},
      {x:x1,  y:lerp(y1,y0,t)},
      {x:lerp(x1,x0,t),  y:y1},
      {x:lerp(x0,x1,t),  y:y1},
      {x:x0,  y:lerp(y1,y0,t)},
      {x:x0,  y:lerp(y0,y1,t)},
    ],
    name:rc.name
  };
}

function averagePoint(a,b){
  return {x:(a.x+b.x)/2, y:(a.y+b.y)/2}
}
function distSquared2d(a,b){
   dx=b.x-a.x; dy=b.y-a.y; return dx*dx+dy*dy;
}
g_snapRadius=5;

// any polygon points that are colinear with prev/next deemed extraneous - remove
function trimPolyPoints(poly) {
  newpoints=[];
  if (poly.points.length<3) {return;}
  num=poly.points.length;
  for (i=0; i<num; i++) {
     iprev=(i+num-1)%num;
     inext=(i+1)%num;
     pt=poly.points[i];
     midpoint=averagePoint(poly.points[iprev],poly.points[inext]);
     if (distSquared2d(midpoint,pt)>g_snapRadius*g_snapRadius){
       newpoints.push(pt);
     }
  }
  if (newpoints.length!=poly.points.length){
    poly.points=newpoints;
  }
}

function polyFromLine(v0,v1,name){
  return{
    points:[v0,v1],
    name:name
  }
}
function polyFromPoint(v0,name){
  return{
    points:[v0],
    name:name
  }
}
function makeQuad(v0,v1,v2,v3,nm){
	var newpoly= {points:[v0,v1,v2,v3],name:nm};
	return newpoly;
}
function fillCircle(context, x,y,r) {
  context.beginPath();
  context.arc(x, y, r, 0, 2*Math.PI);
  context.fill();
}

function drawRectOutline(context,start,end){
  context.beginPath();
  context.moveTo(start.x,start.y);
  context.lineTo(end.x,start.y);
  context.lineTo(end.x,end.y);
  context.lineTo(start.x,end.y);
  context.lineTo(start.x,start.y);
  context.stroke();
}
function dragFeedbackCrosshairFull(context){
  drawCrosshairFull(context,g_mousepos);
}
function drawPointSnapCrosshair(ctx,cursorPos){
  vt=pickPointAt(cursorPos);
  drawCrosshair(ctx,vt?vt:cursorPos,g_snapRadius*2);
  if (vt) { fillCircle(ctx,vt.x,vt.y,g_snapRadius);}
}

function dragFeedbackCrosshair(context){
  drawPointSnapCrosshair(context,g_mousepos,g_snapRadius);
}

function dragFeedbackRectSub(context,color,alpha){
    context.globalAlpha=alpha;
    context.fillStyle = color;
    context.beginPath();
    context.moveTo(g_dragstart.x,g_dragstart.y);
    context.lineTo(g_mousepos.x,g_dragstart.y);
    context.lineTo(g_mousepos.x,g_mousepos.y);
    context.lineTo(g_dragstart.x,g_mousepos.y);
    context.closePath();
    context.fill();
}
function dragFeedbackRect(context){
	dragFeedbackRectSub(context,"red",0.25);
}
function dragFeedbackSelectRect(context){
	if (g_leftmousebutton){
		dragFeedbackRectSub(context,"green",0.25);
	}
}
function dragFeedbackMultiSelect(context){
	drawCrosshairFull(context,g_mousepos);
	drawFeedbackPickPolyPoint(context);
}

function getSnappedRefPoint(cursor){
   vt=pickPointAt(cursor);
   return vt?vt:cursor;
}

function dragFeedbackLine(context){
    context.globalAlpha=0.75;
    context.strokeStyle = "red";
    context.beginPath();
    context.moveTo(g_dragstart.x,g_dragstart.y);
    endpoint=getSnappedRefPoint(g_mousepos);
    context.lineTo(endpoint.x,endpoint.y);
    context.stroke();
    drawPointSnapCrosshair(context,g_mousepos);
}

function pickPointAt(cursorPt) {
  vertex=null;
  minDist2=g_snapRadius*g_snapRadius;
  for (pli=0; pli<g_polys.length; pli++) {
    pl=g_polys[pli];
    for (pti=0; pti<pl.points.length; pti++) {
       d2=distSquared2d(pl.points[pti],cursorPt);
       if (d2<minDist2){
         minDist2=d2;
         vertex=pl.points[pti];    
       }  
    }
  }
  return vertex;
}

function pickOrMakePoint(cursorPt){
  vt=pickPointAt(cursorPt);
  if (vt) {return vt;}
  // makes a free point assuming it will be used.
  return {x:cursorPt.x, y:cursorPt.y};
//  newpl=polyFromPoint(cursorPt,"");
//  AddPoly(newpl);
//  return newpl.points[0];
}

function IsVisible(pli){
   if (g_showAllPolys){return true;}
   return pli==g_currentPoly;
}

function pickPolyFeatureAt(cursorPt){
  picked={pointIndex:-1,polyIndex:-1,edgeIndex:-1,edgeFraction:0.0,point:{}};
  minDist2=10000*10000;

  for (pli=0; pli<g_polys.length; pli++) {
    if (!IsVisible(pli)){continue;}
    pl=g_polys[pli];

    // pick the polygon centre?
    centre=polyCentre(pl.points);
    d2=distSquared2d(centre,cursorPt);
    if (d2<minDist2 && d2<g_snapRadius*g_snapRadius){
       minDist2=d2;
       picked.edgeIndex=-1;
       picked.pointIndex=-1;
       picked.polyIndex=pli;
       picked.pickedPoint=centre;
    }
    // pick polygon Edge?
    for (pti=0; pti<pl.points.length; pti++) {
       pti1=(pti+1)%pl.points.length;
       edgeCentre=averagePoint(pl.points[pti],pl.points[pti1]);
       d2=distSquared2d(edgeCentre,cursorPt);
       if (d2<=minDist2){
         minDist2=d2;
         picked.polyIndex=pli;
         picked.edgeIndex=pti;
         picked.pointIndex=-1;
         picked.pickedPoint=edgeCentre;
       } 
    }    
    
    // pick polygon vertex?
    for (pti=0; pti<pl.points.length; pti++) {
      pt=pl.points[pti];
      d2=distSquared2d(pt,cursorPt);
      if (d2<=minDist2){
         minDist2=d2;
         picked.pointIndex=pti;
         picked.polyIndex=pli;
         picked.edgeIndex=-1;
         picked.pickedPoint=pt;
      }
    }

    
  }
  return picked;
}

function drawFeedbackDrawPoly(context){
    if (g_drawingPoly.length>0){
      context.globalAlpha=0.75;
      context.strokeStyle = "red";
      endpt=pickOrMakePoint(g_mousepos);
      if (distSquared2d(g_drawingPoly[0],g_mousepos)<g_snapRadius*g_snapRadius) {
        endpt=g_drawingPoly[0];
        context.strokeStyle = g_currentPolyOutline;
        context.globalAlpha=1.0;
      }
      context.beginPath();
      context.moveTo(g_drawingPoly[0].x,g_drawingPoly[0].y);
      for (i=1; i<g_drawingPoly.length; i++){
        context.lineTo(g_drawingPoly[i].x,g_drawingPoly[i].y);
      }
      context.lineTo(endpt.x,endpt.y);
      context.stroke();
    }
    dragFeedbackCrosshair(context);
}

function polyCentre(poly){
   tx=0,ty=0;
   for (i=0; i<poly.length; i++){
     tx+=poly[i].x; ty+=poly[i].y;
   }
   return {x: tx/poly.length, y:ty/poly.length};
}

function drawFeedbackPickPolyPoint(ctx) {
	ctx.globalAlpha=0.5;
  picked = g_adjustPoint?g_adjustPoint:pickPolyFeatureAt(g_mousepos);
  if (picked.polyIndex>=0) {
     pt=(picked.edgeIndex>=0)?picked.pickedPoint:(picked.pointIndex>=0)?g_polys[picked.polyIndex].points[picked.pointIndex]:picked.pickedPoint;
   
    fillCircle(ctx,pt.x,pt.y,g_snapRadius);
  }
}
function drawFeedbackSelectTool(ctx){
//	drawFeedbackPickPolyPoint(ctx);
	pt = pickPointAt(g_mousepos);
	if (pt){
	    fillCircle(ctx,pt.x,pt.y,g_snapRadius);
	}
	
	drawCrosshairFull(ctx,g_mousepos);
}

function drawCrosshairFull(context,cursor){
  context.strokeStyle="#ffffff";
  context.globalAlpha=0.25;
  context.beginPath();
  context.moveTo(cursor.x,0);
  context.lineTo(cursor.x,1080);
  context.stroke();
  context.beginPath();
  context.moveTo(0,cursor.y);
  context.lineTo(1920,cursor.y);
  context.stroke();
}
function drawCrosshair(context,cursor,size){
  context.strokeStyle="#ffffff";
  context.globalAlpha=0.5;
  context.beginPath();
  context.moveTo(cursor.x,cursor.y-size);
  context.lineTo(cursor.x,cursor.y+size);
  context.stroke();
  context.beginPath();
  context.moveTo(cursor.x-size,cursor.y);
  context.lineTo(cursor.x+size,cursor.y);
  context.stroke();
}

function drawRotatedText(ctx,txt,x,y,a){
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(a);
  ctx.textAlign = "center";
  ctx.fillText(txt, 0, 0);
  ctx.restore();
}
function drawSaneRotatedText(ctx,txt,x,y,a){
   if (a>3.142*0.5) a-=3.142;
   if (a<-3.142*0.5) a+=3.142;
   drawRotatedText(ctx,txt,x,y,a);
}


function drawStatusInfo(ctx) {
    ctx.font = "10px Arial";
	ctx.textAlign="left";
	ctx.fillStyle=g_currentPolyOutline;

	text=g_tool.name+"\n";
	text+="x="+g_mousepos.x+" y="+g_mousepos.y;
	ctx.globalAlpha=0.75;
	ctx.fillStyle="#000000";
	ctx.fillText(text,20, 22);
	ctx.fillStyle="#ffffff";
	ctx.fillText(text,20, 20);
}

function repaint() {
  var canvas = document.querySelector("canvas");
  var context = canvas.getContext("2d");
  if (!g_img.ready) {
    
    context.font = "20px Arial";
    context.fillText("loading\n"+g_img.src,0,0);

    return;
  }
  if (g_currentPoly>g_polys.length){currentPoly=-1;}
  g_showLabelNames=document.getElementById("showLabels").checked;
  g_showAllPolys=document.getElementById("showAllPolys").checked;  
  console.log(document.getElementById("showLabels").checked);
 
  context.globalAlpha=1.0;
  img=g_img;
  context.drawImage(img,0,0,img.width,img.height,0,0,g_scaled_w,g_scaled_h);

  context.globalAlpha=0.5;

  context.fillStyle = "green";

  context.strokeStyle="#00ff00";
  var textHeight;
  if (g_polys.length<8){
    textHeight=20.0;
    context.font = "20px Arial";
  } else if(g_polys.length<16){
    textHeight=15.0;
    context.font = "15px Arial";
  }else{
    textHeight=10.0;
    context.font = "10px Arial";
  }

  // Show polys
  for (pli=0; pli<g_polys.length; pli++){
    if (!IsVisible(pli)) continue;
    pl=g_polys[pli];

    // account for selection in rendering style.
    currentPolyOutlineColor = (pli==g_currentPoly)?g_currentPolyOutline:pl.color;


    // fill the area
    context.globalAlpha=0.25;
    if (pl.points.length>2){
      context.beginPath();
      context.moveTo(pl.points[pl.points.length-1].x,pl.points[pl.points.length-1].y);
      for (j=0; j<pl.points.length; j++) {
        context.lineTo(pl.points[j].x,pl.points[j].y);
      }
      context.closePath();
      context.fillStyle = pl.color;
      context.fill();
    }

    context.globalAlpha=0.75;
    context.fillStyle=currentPolyOutlineColor;
    if (g_showVertices){
      for (j=0; j<pl.points.length; j++) {
		vt=pl.points[j];
		size=vt.tag?g_snapRadius:g_snapRadius/2;
        fillCircle(context,pl.points[j].x,pl.points[j].y,size)
      }
    }

    // get the centroid
    pos=polyCentre(pl.points);
    // stroke the outline
    context.strokeStyle = currentPolyOutlineColor;
    context.globalAlpha=0.75;
    context.beginPath();

    context.moveTo(pl.points[pl.points.length-1].x,pl.points[pl.points.length-1].y);
    if (pl.points.length==1){ // it's a single-point crosshair
      
      context.moveTo(pos.x-g_snapRadius*2,pos.y);
      context.lineTo(pos.x+g_snapRadius*2,pos.y);
      context.stroke();
      context.moveTo(pos.x,pos.y-g_snapRadius*2);
      context.lineTo(pos.x,pos.y+g_snapRadius*2);
      context.stroke();
    }
    else for (j=0; j<pl.points.length; j++) { // it's a prpper poly.
      context.lineTo(pl.points[j].x,pl.points[j].y);
    }
   
    context.stroke();
    // draw the label name.
    context.globalAlpha=0.75;
    if (g_showLabelNames){
      var textWidth = context.measureText(pl.name).width;
   
// text label black background
//       context.globalAlpha=(pli==g_currentPoly)?0.5:0.25;
//      context.fillStyle = "black";
//      context.fillRect(pos.x-textWidth/2,pos.y-textHeight/2, textWidth, textHeight);
      context.globalAlpha=(pli==g_currentPoly)?1.0:0.75;
      context.fillStyle = g_labelColor;
      if (pl.points.length==2){
         drawSaneRotatedText(context,pl.name, pos.x,pos.y, Math.atan2(pl.points[1].y-pl.points[0].y, pl.points[1].x-pl.points[0].x))
      } else{
        context.textAlign="center";
        context.fillText(pl.name,pos.x,pos.y);
      }
    }
  }

  // show current tool feedback
  if (g_drawfeedback){
    g_drawfeedback(context);
  }

  drawStatusInfo(context);
}


function getCurrentLabel(){
// get the entered label and cache it.
val= document.getElementById("currentLabel").value; g_presetLabels[g_presetLabelIndex]=val; return val;}
function setCurrentLabel(newval){document.getElementById("currentLabel").value=newval;}

function IncWrap(val,inc,max){
  if (max==0) return 0;
  next=val+inc;
  if (next<0)next+=max;  
  return next%max;
}
function TogglePresetLabel(dir){
  g_presetLabelIndex=IncWrap(g_presetLabelIndex,dir,g_presetLabels.length);
  setCurrentLabel(g_presetLabels[g_presetLabelIndex]);
}
function ToggleCurrentPoly(dir){
  g_currentPoly=IncWrap(g_currentPoly,dir,g_polys.length);  
  repaint();
}


// rectangular-drag creation tools -
// several variations for different actual shapes

function makeRectToolVariant(polyCreateFn,txt){
  return{
	name:txt,
    activate: function(e){
       g_drawfeedback=dragFeedbackCrosshairFull;
    },
    mousedown: function(e){
      g_drawfeedback=dragFeedbackRect;
    },
    mousemove: function(e){
    },
    mouseup:function(e){
        newrect={start:g_dragstart,end:g_mousepos,name: getCurrentLabel()};
    
        if (distSquared2d(g_dragstart,g_mousepos)>0){
          AddPoly(polyCreateFn(newrect));
        }
        g_drawfeedback=dragFeedbackCrosshairFull;
    }
  }
}

g_hexTool=makeRectToolVariant(polyDiagonalHexFromRect,"draw diagonal hexagon");
g_octTool=makeRectToolVariant(polyOctFromRect,"draw octagon");
g_rectTool=makeRectToolVariant(polyFromRect,"draw rect");

g_lineTool={
  name:"draw edges",
  activate: function(e){
     g_drawfeedback=dragFeedbackCrosshair;
  },

  mousedown: function(e){
      g_drawfeedback=dragFeedbackLine;
  },
  mouseup:function(e){
      
      newline={start:g_dragstart,end:g_mousepos};
      // only issue if there is length.
      if (distSquared2d(g_dragstart,g_mousepos)>0){
        vstart=pickOrMakePoint(g_dragstart);
        vend=pickOrMakePoint(g_mousepos);
        AddPoly({points:[vstart,vend], name:getCurrentLabel()});
      }
      g_drawfeedback=dragFeedbackCrosshair;
  },
  cancel:function(){
      g_dragstart=g_mousepos;
      g_drawfeedback=dragFeedbackCrosshair;
  }
};

g_polyTool={
  name:"draw polygon",
  activate: function(e){
     g_drawfeedback=dragFeedbackCrosshair;
  },

  mousedown: function(e){
      g_drawfeedback=drawFeedbackDrawPoly;
      console.log("add poly point");
      if (g_drawingPoly.length>2){
        if (distSquared2d(g_mousepos,g_drawingPoly[0])<g_snapRadius*g_snapRadius){
          console.log("finish poly");
          AddPoly({points:g_drawingPoly,name:getCurrentLabel()});
          g_drawingPoly=[];
          return;
        }
      }
      g_drawingPoly.push(pickOrMakePoint(g_mousepos));

  },
  mouseup:function(e){
  },
  cancel:function(){
     g_drawingPoly=[];
  }
};
g_adjustPoint=null;

g_pointTool={
  name:"draw points",
  activate:function(e){
    g_adjustPoint=null;
    g_drawfeedback=dragFeedbackCrosshair;
  },
  mousedown: function(e){
      console.log("add  point");
      pt=pickOrMakePoint(g_mousepos);
      AddPoly(polyFromPoint(pt,getCurrentLabel()));
  },
  mouseup: function(e){
  },
  mousemove: function(e){
  }
};

function splitEdgeOfPoly(poly, v0,v1, vmid) {
	console.log("splitEdgeOfPoly");
	// 2 types of edgeplit, if the poly is just an edge, make 2 polys with new vertex
	// else split in the boundary
	if (poly.points.length==2){
	    if (poly.points[0]==v0 && poly.points[1]==v1 || poly.points[1]==v0 && poly.points[0]==v1 ) {
			console.log("splitEdgeOfPoly-do edge split");
			var splitpoly=g_polys[g_adjustPoint.polyIndex];
			poly.points[0]=v0;
			poly.points[1]=vmid;
			AddPoly( polyFromLine(vmid,v1, poly.name));
		}
	} else{
		for (var i=0; i<poly.points.length; i++) {
			var i1 =(i+1) % poly.points.length;
			if (poly.points[i]==v0 && poly.points[i1]==v1 || poly.points[i]==v1 && poly.points[i1]==v0) {
				console.log("splitEdgeOfPoly - do polyedge split");
				poly.points.splice(i1,0, vmid);
				break;
			}
		}
	}
}

function getIndexOfPoint(poly,pt){
	for (var i=0; i<poly.points.length; i++) {
		if (poly.points[i]==pt)
			return i;
	}
	return -1;
}
function clearVertexTags(){
	for (i=0; i<g_polys.length;i++){
		pl=g_polys[i];
		for (j=0; j<pl.points.length; j++){
			pl.points[j].tag=false;
		}
	}
}

g_selectTool={
	name:"select",
	activate(e){
	    g_drawfeedback=drawFeedbackSelectTool;
	},
	mousemove: function(e){
		multiSelectMouseMove(e);
	},
	mousedown: function(e){
		multiSelectMouseDown(e);
	},
	mouseup: function(e){
		multiSelectMouseUp(e);
	},
	cancel: function(){
		g_adjustPoint=null;
	    g_drawfeedback=drawFeedbackSelectTool;
	}
};

function foreachVertex(f){
	for (i=0; i<g_polys.length;i++){
		for (j=0; j<g_polys[i].points.length; j++){
			f(g_polys[i].points[j])
		}
	}
}
function foreachVertexOfPolygon(f){
	for (i=0; i<g_polys.length;i++){
		pl=g_polys[i];
		for (j=0; j<pl.points.length; j++){
			f(pl.points[j],pl);
		}
	}
}
function foreachEdgeOfPolygon(f){
	for (i=0; i<g_polys.length;i++){
		pl=g_polys[i];
		for (j=0; j<pl.points.length; j++){
			f(pl.points[j],pl.points[(j+1)%pl.points.length],pl);
		}
	}
}

function extrudeTaggedVertices(){
	console.log("extrude");
	var extrudeEdges=[];
	var exvs=new Map();
	var extrudedv=new Map();
	for (i=0; i<g_polys.length;i++){
		pl=g_polys[i];
		// todo - full poly extrusion logic.
		for (j=0; j<pl.points.length; j++){
			va=pl.points[j];
			vb=pl.points[(j+1)%pl.points.length];
			if (va.tag && vb.tag){
				edge=[va,vb];
				extrudeEdges.push(edge);
				exvs.set(va,true);
				exvs.set(vb,true);
			}
		}
	}
	console.log("extruded edges count="+extrudeEdges.length+"\n"+
		"extruded vertices count"+extrudedv.length);

	// make the extruded vertices
	exvi=0;
	foreachVertex(function(v){
		// foreach vertex can hit vertices multiple times!
		if (exvs.has(v) && !extrudedv.has(v)){
			extrudedv.set(v,{x:v.x,y:v.y, tag:true,name:v.name});
			v.tag=false;
		}
		exvi+=1;
		v.tag=false;
	});
	exvstr=""
	extrudedv.forEach
	// connect polys for extrusions
	for (i=0; i<extrudeEdges.length; i++){
		e=extrudeEdges[i];
		console.log("extruded edge:"+JSON.stringify(e));
		newpoly=makeQuad(e[0],extrudedv.get(e[0]),extrudedv.get(e[1]),e[1],"");
		AddPoly(newpoly);
	}
	console.log("extrude edges "+ extrudeEdges.length +" vertices="+extrudedv.length);
	for (i=0; i<extrudedv.length; i++){
		
	}
}

g_extrudeTool={
	name:"translate",
	activate:function(e){
		console.log("extrude polygons");
		g_drawfeedback=null;
		g_mouseDelta={x:0,y:0};
		extrudeTaggedVertices();
	},
	mousemove: function(e){
		foreachVertex(function(v){if (v.tag){v.x+=g_mouseDelta.x; v.y+=g_mouseDelta.y}});
		
	},
	mouseup: function(e){},
	mousedown: function(e){
		SetTool(g_selectTool);
	},
	cancel: function(e){
		SetTool(g_selectTool);
	}
}
g_multiSelectDrag=false;
function multiSelectMouseMove(e) {
	console.log("multi select move\n");
	g_drawfeedback=dragFeedbackSelectRect;
}
function inrange(a,lo,hi){return a>=lo && a<=hi;}
function multiSelectMouseUp(e){
	console.log("multi select mouse up\n");
	var selectedVertices=new Map();
	foreachVertex(function(v){selectedVertices.set(v,true);});
	minx=Math.min(g_dragstart.x,g_mousepos.x);
	maxx=Math.max(g_dragstart.x,g_mousepos.x);
	miny=Math.min(g_dragstart.y,g_mousepos.y);
	maxy=Math.max(g_dragstart.y,g_mousepos.y);
	selectedVertices.forEach(function(val,vt,map){
		if (inrange(vt.x, minx,maxx) && inrange(vt.y,miny,maxy)){
			vt.tag=vt.tag?false:true
		}
	});
	g_multiSelectDrag=false;
	g_dragfeedback=null;
	if (g_tool.cancel){
		g_tool.cancel();
	}
}

function multiSelectMouseDown(e) {
	console.log("multi select click\n");
	g_multiSelectDrag=true;
    var pick=pickPolyFeatureAt(g_mousepos);
    if (pick.polyIndex>=0){
      g_currentPoly=pick.polyIndex;
      g_adjustPoint=pick;
      if (pick.pointIndex>=0){
        console.log("move point..");
      }
    }
	var pt=pickPointAt(g_mousepos);
	if (!pt){
		if (pick.pointIndex>=0){
			pt=g_polys[pick.polyIndex].points[pick.pointIndex];
		}
	}
	if (pt){
        console.log("tag a point..\n");
		pt.tag=(pt.tag)?false:true;
	}
}

g_adjustTool={
  name:"adjust vertices/edgesplit",
  activate:function(e){
    g_drawfeedback=drawFeedbackPickPolyPoint;
  },
  mousemove: function(e){
    if (g_adjustPoint){
      //can only adjust current poly
	  // TODO: Clean this up by going through vertex tag/translate

      // edge split operation?
	  var pointToMove;
      if (g_adjustPoint.edgeIndex>=0){
        console.log("move tool-split edge.");
        var pl=g_polys[g_adjustPoint.polyIndex];
        var pti1=(g_adjustPoint.edgeIndex+1)%pl.points.length;
        var edgeStart=pl.points[g_adjustPoint.edgeIndex];
        var edgeEnd=pl.points[pti1];
        newPt=averagePoint(edgeStart,edgeEnd);

        //newPt=g_mousepos;
        // step through all the polys again, because the vertices/edge may be shared.
   
        for (var i=0; i<g_polys.length; i++) {
           splitEdgeOfPoly(g_polys[i], edgeStart,edgeEnd, newPt);
        }
		pointToMove = newPt;
		g_adjustPoint.edgeIndex=-1;
		g_adjustPoint.pointIndex=getIndexOfPoint( g_polys[g_adjustPoint.polyIndex], newPt);
		// repick because geometry changed.
	  }

      pl=g_polys[g_adjustPoint.polyIndex];
      if (g_adjustPoint.pointIndex>=0){
        //move a vertex..
   		pointToMove = g_polys[g_adjustPoint.polyIndex].points[g_adjustPoint.pointIndex];
		pointToMove.x+=g_mouseDelta.x;
        pointToMove.y+=g_mouseDelta.y;
      } else if (g_adjustPoint.edgeIndex<0 && g_adjustPoint.pointIndex<0) {
        // move the whole poly..
        for (pti=0; pti<pl.points.length;pti++){
          pl.points[pti].x+=g_mouseDelta.x;
          pl.points[pti].y+=g_mouseDelta.y;
        }
      }
    }
  },
  mousedown: function(e){
    pick=pickPolyFeatureAt(g_mousepos);
    if (pick.polyIndex>=0){
      g_currentPoly=pick.polyIndex;
      g_adjustPoint=pick;
      if (pick.pointIndex>=0){
        console.log("move point..");
      }
    }
	var pt=pickPointAt(g_mousepos);
	if (!pt){
	    console.log("move point.. pick="+JSON.stringify(pick));
		if (pick.pointIndex>=0){
			pt=g_polys[pick.polyIndex].points[pick.pointIndex];
		}
	}
	if (pt){
        console.log("tag a point..\n");
		if (!g_shift){
			clearVertexTags();
		};
		if (!pt.tag){
	        console.log("tag new point\n");
		}
		pt.tag=true;
	}
  },
  mouseup: function(e){
    g_adjustPoint=null;
  },
  // cancel,bound to escape key
  cancel: function(){
    g_adjustPoint=null;
    g_drawfeedback=drawFeedbackPickPolyPoint;
  }
};

g_tool=g_hexTool;

function SetTool(tool){
  if (g_tool){
    if (g_tool.deactivate){
      g_tool.deactivate();
    }
  }
  g_tool=tool;
  if (tool.activate){
    tool.activate();
  }
}

// todo create these+buttons programatically
document.getElementById("poly").onclick=function(){SetTool(g_polyTool);};
document.getElementById("line").onclick=function(){SetTool(g_lineTool);};
document.getElementById("point").onclick=function(){SetTool(g_pointTool);};
document.getElementById("rect").onclick=function(){SetTool(g_hexTool);};
document.getElementById("adjust").onclick=function(){SetTool(g_adjustTool);};

// JSON dump. TODO - connect to a server etc etc

function download(filename, text) {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  element.setAttribute('download', filename);

  element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}

function GetAsJSON(){
  return JSON.stringify(
   { imageurl:      g_img.src,//document.getElementById("imageurl").value,
     scaled_width:  g_scaled_w,
     scaled_height: g_scaled_h,
     polygons:      g_polys
   });
}
var g_downloadIndex=0;

// load the scene from a text file
function loadFromText(txt){
   var inputJSON=JSON.parse(txt);
   if (!inputJSON){
     alert("must load JSON format");
     return;
   }
   if (!inputJSON.imageurl && inputJSON.polygons){
     alert("incorret format, needs imageurl,polygons");
     return;
   }

   alert("Loading annotations for:"+inputJSON.imageurl);
//   LoadImage(inputJSON.imageurl); // doesnt work.. 
   // todo- how to safely set UI etc
   g_img.src=inputJSON.imageurl;
//   document.getElementById("imageurl").value;
   console.log("setting new polys,num= "+inputJSON.polygons.length);
   g_polys=inputJSON.polygons;
}

document.getElementById("save").onclick=function(){
   filename=prompt("download as","annotations"+g_downloadIndex+".json"); g_downloadIndex+=1;
//   alert(GetAsJSON());
   download(filename,GetAsJSON());
};

// drag drop the annotation file in for load.
editor.ondragover=function(ev){
//  console.log("dragover");
  ev.preventDefault();
}
editor.ondrop=function(ev){
  console.log("got a drop");
  ev.preventDefault();
  var dt=ev.dataTransfer;
  var url=dt.getData('URL');
  if (!url){url=dt.getData('url')}

  if (!url) {
    url = dt.getData('text/plain');
  }
  if (!url) { url=dt.getData('text');}
  if (!url) { url=dt.getData('Text');}
  if (!url) { url=dt.getData('text/plain');}
  if (!url) { url=dt.getData('text/html');}
  if (!url) {
        url = dt.getData('text/uri-list');
  }

  alert("url="+url+"\n"+JSON.stringify(dt));

  if (dropdata){var dropurl = dropdata.attr('src');
    if (!dropurl) 
      dropurl = dropdata.find("img").attr('src');
  }

  if (dropurl) {
    alert("url="+dropurl);
    // process URL drop
    console.log("got URL drop?:"+url); 
    LoadImage(url);
    g_polys=[];

  }
  else {
    // process File data drop
    var files = ev.target.files || ev.dataTransfer.files;

    for (var i=0,file; file=files[i];i++){
      console.log("got file drop:"+file+" l="+file.length); 
      reader = new FileReader();
      reader.onload = function(event) {
        console.log("file loaded:"+event.target);
        data = event.target.result;
        console.log("file loaded bytes="+data.length);
        loadFromText(data);        
      };
      reader.readAsText(file);
    }
  }
}

document.getElementById("load").onclick=function(){
   var txt=prompt("enter JSON annotations");
   if (!txt){return;}
   
   // grab the stuff.
   loadFromText(txt);
};

function readMousePos(e) {
  var edrect = editor.getBoundingClientRect();

  var opos=g_mousepos;
  console.assert(e.clientX && e.clientY);
  g_mousepos={x:e.clientX-edrect.left,y:e.clientY-edrect.top};
  g_mouseDelta.x=g_mousepos.x-opos.x;
  g_mouseDelta.y=g_mousepos.y-opos.y;
}

editor.addEventListener('mousemove',function(e){
	readMousePos(e);

	if (g_multiSelectDrag){
		multiSelectMouseMove(e);
	}else if (isMultiSelect()){
		g_drawfeedback=dragFeedbackMultiSelect;
	}else {
		if (g_tool.mousemove) {g_tool.mousemove(e);}
	}
	repaint();
});

function RenamePoly(){
  if (g_polys.length<=0) return;
  currentPoly=g_polys[g_currentPoly];
  newname=prompt("enter new label",currentPoly.name);
  currentPoly.name=newname;
  console.log(g_defaultColors[newname]);
  if (g_defaultColors[newname]){
    currentPoly.color=g_defaultColors[newname];
  }
}
function MyConfirm(txt){
	if (!g_promptSevereTools)
		return true;
	return confirm(txt);
}
function DeleteCurrentPoly(){
	console.log("delete a polygon\n");
  if (g_currentPoly>=0 && g_polys.length>0){
    if (!MyConfirm("delete poly:"+g_polys[g_currentPoly].name)){
      g_polys.splice(g_currentPoly,1);
      g_currentPoly=IncWrap(g_currentPoly,0,g_polys.length);
    }
  }
}

function numSelectedVertices(){
	var accum=0;
	foreachVertex(function(v){ if (v.tag){accum+=1;}});
	return accum;	
}
function MergeVertices(){
	console.log("merge vertices");
	var accum=vzero();
	var total=0;
	accum.tag=true;
	foreachVertex(function(v){ if (v.tag){vaddto(accum,v);total+=1;}});
	var newpolys=[];
	if (total>0){
		console.log("vertices to merge:"+total);
		var mergedPt=vscale(accum,1.0/total);
		console.log("merge at:"+JSON.stringify(mergedPt));
		if (!MyConfirm("merge "+total+" vertices \nat"+JSON.stringify(mergedPt))){
			return;
		}

		for (i=0; i<g_polys.length; i++){
			pl=g_polys[i];
			var newpts=[];
			var lastadded=null;
			for (j=0; j<pl.points.length; j++){
				vt=pl.points[j];
				if (!vt.tag){newpts.push(vt);lastadded=vt;}
				else{
					if (lastadded!=mergedPt){
						lastadded=mergedPt;
						newpts.push(mergedPt);
					}
				}
			}
			if (newpts.length>2){
				if (newpts[0]==newpts[1]){ newpts.pop();}
			}
			if (newpts.length>1){
				newpolys.push({points:newpts,color:pl.color, name:pl.name});
			}
		}
		g_polys=newpolys;
	}
}
function cloneVertex(v){
	return {x:v.x, y:v.y, tag:v.tag, name:v.name, color:v.color}
}
function SeperateVertices(){
	console.log("seperate vertices");
	vertexPolyMap=new Map(); // every combination of poly,vertex
	for (i=0;i<g_polys.length;i++){
		pl=g_polys[i];
		for (j=0; j<pl.points.length;j++){
			vt=pl.points[j];
			// create or get a map for the vertex,
			if (!vertexPolyMap.has(vt)) {
				vertexPolyMap.set(vt,new Map());
			}
			polysPerVertex=vertexPolyMap.get(vt);
			// put the poly's respective version on the vertex
			polysPerVertex.set(pl,(!vt.tag)?vt: cloneVertex(vt));
			// mark that the vertex has this poly
		}
	}
	// pass 2 change whats needed
	for (i=0;i<g_polys.length;i++){
		pl=g_polys[i];
		for (j=0; j<pl.points.length;j++){
			vt=pl.points[j];
			newvt=vertexPolyMap.get(vt).get(pl);
			pl.points[j]=newvt;
		}
	}
}

function DeleteVertices(){
	console.log("delete vertices\n");
	var newpls=[];
	for (i=0;i<g_polys.length; i++){
		var pl=g_polys[i];
		var newpl={points:[],color:pl.color,name:pl.name};
		for (j=0; j<pl.points.length; j++){
			vt=pl.points[j];
			if (!vt.tag){
				newpl.points.push(vt);
			}
		}
		if (newpl.points.length>=0){
			newpls.push(newpl);
		}
	}
	g_polys=newpls;
	repaint();
}

// context sensitive delete.
function Delete(){
	console.log("context sensitive delete\n");
	var n=numSelectedVertices()
	if (n>0){
		if (MyConfirm("delete "+n+" vertices?")){
			DeleteVertices();
		}
	} else {
		DeleteCurrentPoly();
	}
}

function foreachPolygonEdge(f){
	for (i=0;i<g_polys.length; i++){
		pl=g_polys[i];
		for (j=0; j<pl.points.length; j++){
			pt0=pl.points[j]; pt1=pl.points[(j+1)%pl.points.length];
			f(pl,pt0,pt1);
		}
	}
}

function edgeMapGetOrInsert(edgeMap, vs,ve, f){
	if (edgeMap.has([vs,ve])) {return edgeMap.get([vs,ve]);}
	if (edgeMap.has([ve,vs])) {return edgeMap.get([ve,vs]);}
	edgeMap.set([vs,ve], f());
	return edgeMap.get([vs,ve]);
}

function getEdgeMapFiltered(predicate_func) {
	edgeMap=new Map();
	foreachPolygonEdge(function(pl,vs,ve) {
		if (predicate_func(pl,vs,ve)){
			em=edgeMapGetOrInsert(edgeMap,vs,ve, function(){return new Set();});
			if (em){
				em.set(pl,true);
			}
			edgeMap.set([vs,ve], true); // every polygon of that edge aswell?
		}
	});
	return edgeMap;
}
function getSelectedEdgesByVertices(){
	return getEdgeMapFiltered(function(pl,vs,ve){return vs.tag && ve.tag;});
}
function edgeMapGet(edgeMap,vs,ve){
	if (edgeMap.has([vs,ve])) {return edgeMap.get([vs,ve]);}
	if (edgeMap.has([ve,vs])) {return edgeMap.get([ve,vs]);}
	return null;
	
}

function edgeMapGetOrCreate(edgemap, vs,ve){
	var verticesPerVertex = edgemap.get(vs);
	if (!verticesPerVertex){
		verticesPerVertex=new Map();
		edgemap.set(vs,verticesPerVertex);
	}
	var edge=verticesPerVertex.get(ve);
	if (edge){return edge;}
	// first check if the other vertex has this link..
	othervm=edgemap.get(ve);
	if (!othervm){
		othervm=new Map();
		edgemap.set(ve,othervm);
	}
	otherEdge= othervm.get(vs);
	if (otherEdge){
		// if so store and return
		verticesPerVertex.set(ve,otherEdge);
		return otherEdge;
	}

	// otherwise, make a new edge..
	edge=[vs,ve];
	verticesPerVertex.set(ve,edge);
	othervm.set(vs,edge);
	return edge;
}
function makeEdgeMap(){
	// 
	ptedges=new Map();
	for (i=0; i<g_polys.length; i++){
		pl=g_polys[i];
		for(j=0; j<pl.points.length;j++){
			var vs=pl.points[j];
			var ve=pl.points[(j+1)%pl.points.length];
			edgeMapLink(ptedges,vs,ve);
			edgeMapLink(ptedges,ve,vs);
		}
	}
}

function CopyToClipboard(){
	console.log("TODO-clipboard copy, hack ctrl-v is just duplicate");	
}

function CutToClipboard(){
	console.log("TODO-clipboard copy, hack ctrl-v is just duplicate");
	CopyToClipboard();
	DeleteSelectedPolygons();
}


function PasteFromClipboard(){
	console.log("paste/duplicate - no clipboard yet so we paste");
	// todo: poly mode, vertex mode, edge mode
	// or poly/vertex/edge mixed selection
	selPolyMap=new Map();
	selVertexMap=new Map();
	foreachVertexOfPolygon(function(vt,pl){
		if (vt.tag){selPolyMap.set(pl,true);}
	});
	foreachVertexOfPolygon(function(vt,pl){
		if (selPolyMap.get(pl)){
			selVertexMap.set(vt,vt);
		}
	});
	// duplicate at the cursor?
	var accumvt=vzero();
	var numpts=0;
	selVertexMap.forEach(function(val,keyvt,map){
		newvt=cloneVertex(keyvt)
		selVertexMap.set(keyvt, newvt);
		newvt.tag=true;
		keyvt.tag=false;
		vaddto(accumvt,newvt);
		numpts++;
	});
	var selCentre=vscale(accumvt,1.0/numpts);
	var delta=vsub(g_mousepos,selCentre);
	selVertexMap.forEach(function(newvt,keyvt,map){
		vaddto(newvt,delta);
	});
	selPolyMap.forEach(function(val,keypl,map){
		newpl={points:[],name:keypl.name, color:keypl.color};
		for (i=0; i<keypl.points.length; i++){
			duplicateVt=selVertexMap.get(keypl.points[i]);
			
			newpl.points.push(duplicateVt);
		}
		g_polys.push(newpl);
	});
}

function SubdivideByVertices(){
	// every edge- potentially split in the middle.
	// every poly with 2 vertices - split between them
	// every poly with all vertices set: add a midpoint while you're at it..
/*	console.log("subdivide by vertices");
	var edgemap=getSelectedEdgesByVertices();
	var edgeMidPts=new Map();
	console.log("split edges..:-");
	// create the split points per edge,
	edgemap.forEach(function(val,edge,map){
		midpt=averagePoint(edge[0],edge[1]);
		console.log("edge:"+JSON.stringify(edge)+" made midpoint:"+JSON.stringify(midpt));
		edgeMidPts.set(edge,midpt);
	});
*/
	// vertex -> all the edges off it.
	edgemap=new Map();
	//can't just use [vs,ve] as keys adhoc; must be unique [vs,ve] object
	console.log("create midpoints & build edgemap:-");
	edgeMidPts=new Map();
	for (i=0; i<g_polys.length; i++){
		pl=g_polys[i];
		for(j=0; j<pl.points.length;j++){
			var vs=pl.points[j];
			var ve=pl.points[(j+1)%pl.points.length];
			if (!(vs.tag==true && ve.tag==true)){continue;}
			edge=edgeMapGetOrCreate(edgemap,vs,ve);
			if (edgeMidPts.has(edge)) continue;		
			var midpt=averagePoint(vs,ve);
			edgeMidPts.set(edge, midpt);
		}
	}
	var newpl,midpt;
	var newPolyList=[];
	console.log("subdiv- poly list");
	for (pli=0; pli<g_polys.length;console.log("increment pli"+pli), pli++){
		console.log("subdiv- poly "+pli+"of"+g_polys.length);
		var pl=g_polys[pli];
		var numTagged=0;
		for (j=0; j<pl.points.length; j++){
			if (pl.points[j].tag) {
				numTagged+=1;
			}
		}
		if (!numTagged){
			newPolyList.push(pl);
		} else if (numTagged==pl.points.length ){
			console.log("subdiv- whole poly "+i);
			// subdivide edges and whole polygon:-
			polymidv=polyCentre(pl.points);
			for (vti=0; vti<pl.points.length; vti++){
				// splitting in this order retains obvious quad subdiv
				console.log("subdiv- whole poly"+i+" createSub"+vti);
				var v0=pl.points[vti];
				var v1=pl.points[(vti+1)%pl.points.length];
				var v2=pl.points[(vti+2)%pl.points.length];
				var midv01=edgeMidPts.get(edgeMapGetOrCreate(edgemap,v0,v1));
				var midv12=edgeMidPts.get(edgeMapGetOrCreate(edgemap,v1,v2));
				var subpl={points:[midv01,v1,midv12,polymidv],name:pl.name,color:pl.color};
				newPolyList.push(subpl);
			}
			console.log("done subdiv whole poly ");
		}else{		
			// just subdivide edges
			console.log("subdiv- poly edges");
			newpl={points:[], name:pl.name,color:pl.color};
			for (j=0; j<pl.points.length; j++){

				var vs=pl.points[j];
				var ve=pl.points[(j+1)%pl.points.length];
				newpl.points.push(vs);
				console.log("look for split of"+JSON.stringify([vs,ve]));
	/*			if (edgeMidPts.has([vs,ve]) || edgeMidPts.has([ve,vs])){
					console.log("midpoint there..\n");
				};
				if (edgeMidPts.has([vs,ve])){midpt=edgeMidPts.get([vs,ve]);}
				else if (edgeMidPts.has([ve,vs])){midpt=edgeMidPts.get([ve,vs]);}
				*/
				midpt=null;
				edge=edgeMapGetOrCreate(edgemap,vs,ve);
				if (edgeMidPts.has(edge)){
					console.log("found midpoint: for "+j);
					newpl.points.push(edgeMidPts.get(edge));
				}
			}
			newPolyList.push(newpl);
			console.log("done edge subdiv poly");
		}
	}
	console.log("subdiv- done");
	g_polys=newPolyList;
}
function isMultiSelect(){
	return (g_shift && g_shiftIsMultiSelect);
}
editor.addEventListener('mousedown',
	function(e){

	
		g_leftmousebutton=true;
		readMousePos(e);
		g_dragstart=g_mousepos;

		// todo - inherit shift-overide in the tool func?
		if (isMultiSelect()){
			multiSelectMouseDown(e);
		} else {
			g_tool.mousedown(e);
		}
		repaint();
	}
);
editor.addEventListener('mouseup',   function(e){
	g_leftmousebutton=false;
	readMousePos(e);
	if (g_multiSelectDrag){
		multiSelectMouseUp(e);
		g_multiSelectDrag=false;
	}else {
		g_tool.mouseup(e);
	}
	repaint();
});
window.addEventListener('keyup', function(e){
  kc=e.keyCode;
  console.log("keyup:"+kc);
  if (kc==16){g_shift=false;} 
  if (kc==17){g_ctrl=false;}
  if (kc==18){g_alt=false;}
});
function isCommandModifier(e){
	return (g_ctrl || e.getModiferState("OS"));
}
window.addEventListener('keydown',  function(e){
  kc=e.keyCode;
  console.log("keypress:"+kc);
  // todo - programatic, show hotkeys.
  if (kc==16){g_shift=true;} 
  if (kc==17){g_ctrl=true;}
  if (kc==18){g_alt=true;} 

  if (kc==82){SetTool(g_hexTool)} 
  else if (kc==66){SetTool(g_octTool)}
  else if (kc==65){SetTool(g_adjustTool)}
  else if (kc==69){SetTool(g_extrudeTool)}
  else if (kc==80){SetTool(g_polyTool)}
  else if (kc==83){
	if (g_shift){
		SeperateVertices();
	} else
	SubdivideByVertices();
  }
  //i
  else if (kc==73){}
  //f
  else if (kc==70){}
  //d
  else if (kc==68){}
  //h
  else if (kc==72){}
  //y
  else if (kc==89){}
  //x
  else if (kc==88){}
  //c
  else if (kc==67){if (isCommandModifier(e)) {CopyToClipboard()}}
  //v
  else if (kc==86){if (isCommandModifier(e)) {PasteFromClipboard()}}  
  //z
  else if (kc==90){}

  else if (kc==79){SetTool(g_pointTool)}
  else if (kc==84){SetTool(g_selectTool)}
  else if (kc==76){SetTool(g_lineTool)}
  else if (kc==221){TogglePresetLabel(1);}
  else if (kc==219){TogglePresetLabel(-1);}
  else if (kc==27){g_tool.cancel();}
  else if (kc==13){RenamePoly();}
  else if (kc==188){ToggleCurrentPoly(-1);}
  else if (kc==77){
    MergeVertices();
  }
  else if (kc==190){ToggleCurrentPoly(+1);}
  else if (kc==8){Delete(+1);}
// todo .. parenting, renaming , delete vertex,...
  //readMousePos(e);
  repaint();
},false);

repaint();

var examples=[
  {imageurl:"https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Queen_Street_NOTL_1.jpg/1920px-Queen_Street_NOTL_1.jpg",
  labels:[]},
  {imageurl:"https://upload.wikimedia.org/wikipedia/commons/0/0a/Ickenham_-_water_pump%2C_pub%2C_and_houses_-_geograph.org.uk_-_20123.jpg",
  labels:[]},
{"imageurl":"https://upload.wikimedia.org/wikipedia/commons/5/5f/Vendeur_de_parapluie.jpg","scaled_width":1024,"scaled_height":768,"polygons":[{"points":[{"x":641.2,"y":133},{"x":631,"y":123},{"x":616,"y":118},{"x":602,"y":119},{"x":592,"y":124},{"x":589,"y":137},{"x":573,"y":144.375},{"x":577,"y":153},{"x":592,"y":154},{"x":595,"y":170},{"x":579,"y":243},{"x":563,"y":281},{"x":586,"y":308},{"x":590,"y":340},{"x":592,"y":388},{"x":576,"y":397},{"x":575.8,"y":407},{"x":593,"y":420},{"x":627,"y":417},{"x":633,"y":370},{"x":629,"y":333},{"x":636,"y":306.625},{"x":644,"y":276},{"x":648,"y":255},{"x":655,"y":200},{"x":638,"y":169},{"x":630,"y":151},{"x":640,"y":148}],"name":"person","color":"#1000f0"},{"points":[{"x":454.655,"y":155},{"x":461,"y":137},{"x":479,"y":129},{"x":506,"y":151},{"x":540.375,"y":153},{"x":583,"y":210.5},{"x":576,"y":293},{"x":571,"y":335},{"x":558.345,"y":388},{"x":533,"y":380},{"x":540,"y":363},{"x":506,"y":370},{"x":495.625,"y":364},{"x":523,"y":344},{"x":524,"y":308.5},{"x":493,"y":273},{"x":497,"y":237},{"x":485,"y":186},{"x":463,"y":175}],"name":"person","color":"#1000f0"},{"points":[{"x":659,"y":205.215},{"x":667,"y":190},{"x":679,"y":185},{"x":689,"y":187},{"x":685,"y":175},{"x":693,"y":164},{"x":720,"y":171},{"x":713,"y":197},{"x":743,"y":200},{"x":748.75,"y":193},{"x":814,"y":185.625},{"x":814,"y":207},{"x":797,"y":208},{"x":800,"y":197},{"x":776,"y":202},{"x":772,"y":209},{"x":777,"y":222},{"x":796,"y":228},{"x":812,"y":250},{"x":819,"y":284},{"x":810,"y":311.785},{"x":799,"y":323},{"x":777,"y":326},{"x":750,"y":307},{"x":740,"y":273},{"x":731,"y":269},{"x":723,"y":279},{"x":709,"y":276},{"x":702,"y":289},{"x":687.25,"y":292},{"x":670,"y":285},{"x":659,"y":269.375},{"x":652,"y":238}],"name":"bicycle","color":"#008000"},{"points":[{"x":357,"y":244.605},{"x":378,"y":238},{"x":387,"y":236},{"x":398.75,"y":236},{"x":459,"y":256},{"x":483,"y":278},{"x":504,"y":285.875},{"x":515,"y":332.395},{"x":479,"y":330},{"x":430,"y":306},{"x":404.25,"y":344},{"x":401,"y":341.125},{"x":423,"y":302},{"x":403,"y":289},{"x":375,"y":268}],"name":"umbrella","color":"#008000"},{"points":[{"x":894.06,"y":82},{"x":886,"y":71},{"x":873.5,"y":73},{"x":867,"y":85},{"x":872,"y":99},{"x":868,"y":117.75},{"x":861,"y":128},{"x":840,"y":124},{"x":850,"y":138},{"x":865,"y":148},{"x":869,"y":176},{"x":860,"y":190},{"x":869,"y":191},{"x":879.94,"y":189},{"x":891,"y":182},{"x":886,"y":172},{"x":883.5,"y":153},{"x":903,"y":160.25},{"x":914,"y":145},{"x":913,"y":122},{"x":906,"y":104},{"x":893,"y":94}],"name":"person","color":"#1000f0"},{"points":[{"x":868.62,"y":112},{"x":854,"y":86},{"x":851,"y":76},{"x":841,"y":68},{"x":829,"y":75},{"x":825.5,"y":83},{"x":829,"y":100},{"x":825,"y":109},{"x":815,"y":123},{"x":803,"y":130.125},{"x":812,"y":137},{"x":812,"y":151},{"x":810,"y":163},{"x":795,"y":171},{"x":798.38,"y":180},{"x":818,"y":173},{"x":819,"y":181},{"x":835.5,"y":177},{"x":842,"y":154.875},{"x":842,"y":137},{"x":864,"y":122}],"name":"person","color":"#1000f0"},{"points":[{"x":383.165,"y":83},{"x":364,"y":75},{"x":358.125,"y":60},{"x":333,"y":79.875},{"x":347,"y":93},{"x":340,"y":105},{"x":339,"y":121},{"x":329,"y":128},{"x":332,"y":141},{"x":342,"y":156},{"x":342.835,"y":196},{"x":358,"y":243},{"x":376,"y":239},{"x":377,"y":209},{"x":388.875,"y":238},{"x":410,"y":237.125},{"x":395,"y":181},{"x":407,"y":137},{"x":397,"y":93}],"name":"person","color":"#1000f0"},{"points":[{"x":167.17,"y":79},{"x":191.25,"y":78},{"x":188,"y":97},{"x":195,"y":108.625},{"x":198,"y":137},{"x":212,"y":168},{"x":206.83,"y":176},{"x":173.75,"y":169},{"x":164,"y":157},{"x":155,"y":160},{"x":149,"y":136.375},{"x":150,"y":103},{"x":166,"y":93}],"name":"person","color":"#1000f0"},{"points":[{"x":899,"y":259.76},{"x":927,"y":255},{"x":954,"y":263},{"x":943,"y":224},{"x":991,"y":228},{"x":985,"y":278},{"x":1005,"y":278},{"x":1024,"y":281},{"x":1024,"y":343.24},{"x":998,"y":358},{"x":989,"y":378},{"x":975,"y":379},{"x":971,"y":389},{"x":968,"y":410},{"x":955,"y":413},{"x":935,"y":386},{"x":905,"y":377},{"x":883,"y":348},{"x":878,"y":312}],"name":"bicycle","color":"#008000"},{"points":[{"x":907,"y":209.715},{"x":932.25,"y":207},{"x":955,"y":213.125},{"x":948,"y":232},{"x":952,"y":256.285},{"x":910.75,"y":255},{"x":893,"y":245.875},{"x":894,"y":226}],"name":"food basket","color":"#008000"},{"points":[{"x":67.83500000000001,"y":225},{"x":87,"y":212},{"x":116,"y":217},{"x":109,"y":250},{"x":121,"y":247},{"x":133,"y":231},{"x":153,"y":231},{"x":180,"y":240},{"x":154,"y":268},{"x":193,"y":257},{"x":211,"y":244},{"x":228.875,"y":236},{"x":230,"y":250},{"x":191,"y":278},{"x":242,"y":338},{"x":240,"y":368},{"x":202,"y":402},{"x":295,"y":367},{"x":299,"y":372.375},{"x":285,"y":391},{"x":248,"y":409},{"x":217,"y":417},{"x":239,"y":447},{"x":271,"y":500},{"x":334.165,"y":661},{"x":216.125,"y":663},{"x":189,"y":613},{"x":167,"y":558},{"x":155,"y":501},{"x":144,"y":455},{"x":118,"y":476},{"x":114,"y":465},{"x":88,"y":474.625},{"x":86,"y":464},{"x":131,"y":438},{"x":130,"y":416},{"x":119,"y":400},{"x":76,"y":407},{"x":74,"y":401},{"x":34,"y":408},{"x":29,"y":392},{"x":84,"y":389},{"x":115,"y":376},{"x":110,"y":359},{"x":92,"y":313},{"x":45,"y":320},{"x":42,"y":306},{"x":75,"y":292},{"x":67,"y":270},{"x":73,"y":250}],"name":"parked bicycles","color":"#008000"}]}
];

g_polys=[];
repaint();

</script>
</body>
</html>

