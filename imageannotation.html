<html>
<link rel="stylesheet" type="text/css" href="style.css">
<body>
<style>body{overflow:hidden; width:100%;height:100%;}
</style>
<div id="genImages"></div>
<div>
<button class="button" value="" id="b0">b0</button>
<button class="button" value=""id="b1">b1</button>
<button class="button" value=""id="b2">b2</button>
<button class="button" value=""id="b3">b3</button>
<button class="button" value=""id="b4">b4</button>
<button class="button" value=""id="b5">b5</button>
<button class="button" value=""id="b6">b6</button>
<button class="button" value=""id="b7">b7</button>
<button class="button" value=""id="b8">b8</button>
<button class="button" value=""id="b9">b9</button>
<button class="button" value=""id="b10">b10</button>
<button class="button" value=""id="b11">b11</button>
<button class="button" value=""id="b12">b12</button>
<button class="button" value=""id="b13">b12</button>
<input class="button" id="currentLabel" value="object"title="current label used for new elements">label</button>

<canvas id="editor" width="100pc" height="100pc">
</canvas>
<script>
console.log("hello world 109412");

function Help(){alert(
"hotkeys:\no\tdraw-points tool\nl\tdraw-line tool\nr\tdraw-rect tool\np\tdraw-poly tool\na\tadjust tool (move points & split edges)\n[ ]\ttoggle preset labels;\nenter\trename object;\n< >\tswitch current poly\n"+
"backspace\tdelete polys or vertices\n"+
"save\tdownloads current annotations as JSON\n"+
"drag-drop JSON file to load image & annotations\n"+
"drag drop image URL to begin annotating an image\n"+
"ctrl-V\tduplicate selected poly at cursor\n"+
"cursorkeys,-+\tscroll,zoom\n"+
"F\treset view (show all)\n"+
"w,e,r\ttranslate,rotate,scale tools\n\tclick to select vertices, drag to transform\n"+
"ctrl-A\tselect all\n"+
"ctrl-I\tinvert selection\n"+
"\n"+
"Advanced:-\n"+
"t\tmulti select tool-'tags' (points, rect-drag)\n"+
"shift+LMB\tmulti-select points\n"+
"S\tSubdivide edges/polys by tagged vertices\n"+
"M\tMerge tagged vertices\n"+
"shift-S\tseperate merged vertices\n"+
"alt-E\textrude tagged edges/polys\n"+
"V\ttoggle views (main,nav,3d)\n"+
"shift-P\tparent(parts) tool:  \n\tClick the 'parent', then click each desired part (child)\n"+
"alt-P\tdraw quadstrip\n"+
"'tag' here means 'selected'\n"
)
};
function consolejson(x){
	console.log(JSON.stringify(x));
}
function Info(){
	console.log("show info");
	var info="";
	
	var visit=function(pls,depth){
		for (var i=0; i<pls.length; i++){
			pl=pls[i];
			var txt="";
			for (var j=0; j<depth; j++){txt+="\t";}
			txt+=pl.name;txt+="\t("+pl.points.length+" vertices)";
			txt+="\n";
			info+=txt;
			if (pl.polygons){
				visit(pl.polygons,depth+1);
			}
		}
	};
	visit(g_polys,0);
	alert(info);
}
function NewImage(){
/* confirm overwrite.. shouldn't need when web based.
  if (g_polys.length) {
    if (!confirm("changing URL will lose current polys:"+g_polys.length)){
      return;
    }
  }
*/
  url=prompt("enter image URL");
  if (!url){return;}
  
  LoadImage(url);
  g_polys=[];
  repaint();
}
var g_shift,g_ctrl,g_alt,g_leftmousebutton,g_rightmousebutton,g_midmousebutton;
var g_drawFeedbackColor="red"
editor=document.getElementById("editor");
var g_presetLabels=["object","person","vehicle","plant","animal","tree","building","machine","head","kerb","road marking","barrier","lamppost","bin","window","door","object1","object2","object3"];

labelEdit=document.getElementById("currentLabel");
//? only got dropdown, not combo boxes?
//throw the presets into the dropdown..
//for (i=0; i<g_presetLabels; i++) {
//
//}

var g_defaultColors={
   "person":"#1000f0", "people":"#1000f0", 
   "man":"#0000ff",    "woman":"#2000f0",
   "vehicle":"#ff0000", "car":"#ff0000",
   "bus":"#ff0000",     "truck":"#ff0000",
   "SUV":"#ff0000",     "suv":"#ff0000",
   "plant":"#00ff00",   "bush":"#00ff00",
   "vegetation":"#00ff00", "grass":"#00ff00",
   "tree":"#00ff00",
   "animal":"#800080",   "dog":"#800080",
   "horse":"#800080",    "cat":"#800080",
   "cow":"#800080",      "sheep":"#800080",
   "livestock":"#800080","cattle":"#800080",
   "building":"#c04000", "house":"#c04000",
   "barrier":"#c04000",
   "machine":"#008080",
};
var g_randomColors=[
  "#8000c0","#c08000","#80c000",
  "#0080c0","#c00080","#00c080",
];
function AddPoly(poly){ clr=g_defaultColors[poly.name]; if (clr){poly.color=clr;} else {poly.color=g_randomColors[g_polys.length % g_randomColors.length]}; g_polys.push(poly); g_currPoly=g_polys[g_polys.length-1];}
var g_currPoly=null;
var g_drawingPoly=[];
var g_presetLabelIndex=0;
var g_cursorTxt=0;
var g_showLabelNames=true;
var g_showAllPolys=true;
var g_currentPolyOutline="#ffffff";
var g_promptSevereTools=true;
var g_ctrlIsMultiSelect=true;
var g_mousePos={};
var g_secondTouchPos=null;
var g_secondTouchDelta=null;
var g_enableSplitToDraw;
var g_dragstartpos=null;
var g_polys=[];
var g_tool;
var g_img = new window.Image();
var g_mouseScreenDelta=vzero();
var g_spacebarIsVirtualMouseButton=false; //this is spammy
var g_showVertices=true;
var g_selectedColor="white";
var g_labelColor="white";
var g_hackMoveTaggedVertices=false;
var g_view=null;
var g_viewCentre=vfromxyz(editor.width/2,editor.height/2,0);
var g_zoom=1.0;
var g_imageWorldSize=vfromxyz(1,1,0);
var g_viewMode=0;
// default image to load..
g_img.src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Queen_Street_NOTL_1.jpg/1920px-Queen_Street_NOTL_1.jpg";
g_img.ready=false;

function frameImage(){
  g_zoom = Math.min(editor.width/g_imageWorldSize.x,editor.height/g_imageWorldSize.y);
  //want worldToScreen(viewCentre)=screenCentre
  //
//  g_viewCentre=vfromxyz(0,0,0);
  g_viewCentre=vfromxyz(g_imageWorldSize.x/2,g_imageWorldSize.y/2,0);

}
g_img.onload=function(){
  console.log("image.onload");
  //scale to the image and the window on loading
  editor.width=window.innerWidth;
  editor.height=window.innerHeight;

  g_imageWorldSize=vfromxyz(g_img.width,g_img.height,0);
  frameImage();
  this.ready=true;
  repaint();  
}

function LoadImage(url){
  //TODO: means of using pre-specified scaled sizes.
  g_img.ready=false;
  g_img.src=url;
  console.log("image.src="+url);
}

urlgadget=document.getElementById("imageurl");
if (urlgadget){
  urlgadget.oninput=function(){
    LoadImage(document.getElementById("imageurl").value);
    g_polys=[];
  } 
}
// mini maths lib
function vaddto(lhs,rhs){lhs.x+=rhs.x;lhs.y+=rhs.y; lhs.z+=rhs.z;}
function vsubto(lhs,rhs){lhs.x-=rhs.x;lhs.y-=rhs.y; lhs.z-=rhs.z;}
function vmaddto(lhs,rhs,f){lhs.x+=rhs.x*f;lhs.y+=rhs.y*f; lhs.z+=rhs.z*f;}
function vneg(v){return {x:-v.x, y:-v.y, z:-v.z};};
function vadd(lhs,rhs){return {x:lhs.x+rhs.x, y:lhs.y+rhs.y, z:lhs.z+rhs.z};}
function vmulElem(lhs,rhs){return {x:lhs.x*rhs.x, y:lhs.y*rhs.y, z:lhs.z*rhs.z};}
function vsumElem(a){return a.x+a.y+a.z;}
function vsub(lhs,rhs){return {x:lhs.x-rhs.x, y:lhs.y-rhs.y, z:lhs.z-rhs.z};}
function vabs(v){return {x:Math.abs(v.x), y:Math.abs(v.y), z:Math.abs(v.z)}; }
function vfromxy(vx,vy){return {x:vx,y:vy,z:0};}
function vfromxyz(vx,vy,vz){return {x:vx, y:vy, z:vz};}
function lerp(a,b,f){return (b-a)*f+a;}
function vlerp(a,b,f){
	return {x:lerp(a.x,b.x,f), y:lerp(a.y,b.y,f), z:lerp(a.z,b.z,f)};
}
function vzero(){return {x:0,y:0,z:0}}
function vaxisx(){return {x:1,y:0,z:0}}
function vaxisy(){return {x:0,y:1,z:0}}
function vaxisz(){return {x:0,y:0,z:1}}
function vone(){return {x:1,y:1,z:1}}
function vsplat(s){return {x:x, y:s, z:s}}
function vmax(a,b){return {x:Math.max(a.x,b.x), y:Math.max(a.y,b.y), z:Math.max(a.z,b.z)}}
function vmin(a,b){return {x:Math.min(a.x,b.x), y:Math.min(a.y,b.y), z:Math.min(a.z,b.z)}}

function vmadd(a,b,f){
	return {x:a.x+b.x*f, y:a.y+b.y*f, z:a.z+b.z*f}
}
function vscale(a,f){return {x:a.x*f, y:a.y*f, z:a.z*f}};
function vmulElem(a,b){return {x:a.x*b.x, y:a.y*b.y, z:a.z*b.z}};
function vdot(a,b){return a.x*b.x+a.y*b.y+a.z*b.z;}
function sqr(x){return x*x;}
function clamp(lo,hi,x){return Math.max(lo,Math.min(hi,x));}
function vsqr(v){return vdot(v,v);}
function vcross2d(a,b){return a.x*b.y-a.y*b.x;}
function vlength(a){return Math.sqrt(vsqr(a));}
function vlengthBetween(a,b){return vlength(vsub(b,a));}
function vdist(a,b){return vlength(vsub(a,b));}
function vdistSquared(a,b){return vsqr(vsub(a,b));}
function vcross(a,b){
	return {
		x:a.y*b.z-a.z*b.y,
		y:a.z*b.y-a.y*b.z,
		z:a.x*b.y-a.y*b.x}
}
function vnorm(a){ return vscale(a,1.0/Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z))}
function vtrianglenorm(a,b,c){return vnorm(vcross(vsub(b,a),vsub(c,a)));}
function vperp(a,n){ return vmadd(a,n, -vdot(a,n));}
function vaverage(a,b){
  return {x:(a.x+b.x)/2, y:(a.y+b.y)/2, z:(a.z+b.z)/2}
}

//  var canvas = document.querySelector("canvas");
//  var context = canvas.getContext("2d");
//  context.canvas.width  =window.innerWidth;
//  context.canvas.height =window.innerHeight;

var g_width = window.innerWidth;
var g_height = window.innerHeight;
//var g_scaled_w = 1024; g_scaled_h= (g_scaled_w * g_img.height)/g_img.width;

function lerp(a,b,f){
   return (b-a)*f+a;
}
// transformations
g_axisName=["XZ","ISO","XY","ZY"];
function vchooseAxes(rwpos,axis){
	if (axis==1){//pixelart isometric..
		return {
			x:rwpos.x+rwpos.z,
			y:rwpos.y+(rwpos.x-rwpos.z)/2,
			z:(rwpos.z-rwpos.x)/2};
	}
	if (axis==2){
		return{x:rwpos.x, y:rwpos.y, z:rwpos.z}
	} else if (axis==3){
		return{x:rwpos.z, y:rwpos.y, z:rwpos.x}
	} else if (axis==0){
		return{x:rwpos.x, y:-rwpos.z, z:rwpos.y}
	}
}
function vchooseAxesInv(src,axis){
	if (axis==2){
		return{x:src.x, y:src.y, z:src.z};
	} else if (axis==3) {
		return{x:src.z, y:src.y, z:src.x};
	
	} else if (axis==0) {
		return{x:src.x, y:src.z, z:-src.y};
	} else if (axis==1) {
		return{x:src.x*0.5, y:src.y, z:src.x*0.5};
	}
	//todo - use matrices!
}

function worldToScreen(view, rwpos){
//	console.log(JSON.stringify(view));
	var wpos={};
	wpos=vchooseAxes(vsub(rwpos,view.interestPoint),view.axis);
	return vadd(view.screenCentre,vscale(wpos,view.zoom));
//	return vscale(vadd(wpos,view.interestPoint),view.zoom);
}
function viewIs2d(vw){
//	console.log("vw="+JSON.stringify(vw));
	if (vw.axis==2 || vw.axis==3|| vw.axis==0){
		return true;
	}
	return false;
}
function screenToWorld(view, rspos){
	var spos={};
	spos=vchooseAxes(vsub(rspos,view.screenCentre),view.axis);

	return vadd(view.interestPoint,vscale(spos,1.0/view.zoom));
//	return vsub(vscale(spos,view.zoom),view.interestPoint);
}

function screenPointsToWorld(view,pts){
	wpts=[];
	for (var i=0;i<pts.length;i++){
		wpts.push(screenToWorld(view,pts[i]));
	}
	return wpts;
}
function vctMoveTo(vct,pos){
	var spos=worldToScreen(vct.view, pos);
//	console.log("spos="+JSON.stringify(spos));
	vct.context.moveTo(spos.x,spos.y);
}
function vctLineTo(vct,pos){

	var spos=worldToScreen(vct.view, pos);
//	console.log("spos="+JSON.stringify(spos));
	vct.context.lineTo(spos.x,spos.y);
}
function vctFillCircle(vct, pos,r) {
	var spos=worldToScreen(vct.view, pos);
	vfillcircle(vct.context, spos,r);
}

function Resize(){
  editor.width=window.innerWidth;
  editor.height=window.innerHeight;
	g_width=editor.width;
	g_height=editor.height;
}

function polyDiagonalHexFromRect(view,rc) {
  size=vabs(vsub(rc.end,rc.start));
  var width = size.x;
  var height = size.y;
  x0 = rc.start.x;
  y0 = rc.start.y;
  x1 = rc.end.x;
  y1 = rc.end.y;
  fx=0.75; fy=0.125; // trim a little from the diagonal
  fyy=0.035;
  z=0.0;

  if (width > height) { // wider than tall - split horiz
     return {
      points:screenPointsToWorld(view,[
        vfromxyz(x0,lerp(y0,y1,fyy), z),
        vfromxyz(lerp(x0,x1,fx),y0,	z),
        vfromxyz(x1,   lerp(y0,y1,fy),	z),
        vfromxyz(x1,   lerp(y1,y0,fyy),	z),
        vfromxyz(lerp(x1,x0,fx), y1,	z),
        vfromxyz(x0,   lerp(y1,y0,fy),	z)
      ]),
      name:rc.name
     };
  } else {
     midy=(rc.start.y+rc.end.y)*0.5;
     return {
      points:screenPointsToWorld(view,[
        vfromxyz(lerp(x0,x1,fyy),     y0,z),
        vfromxyz(lerp(x1,x0,fy),     y0,z),
        vfromxyz(x1,     lerp(y0,y1,fy),z),
        vfromxyz(lerp(x1,x0,fyy),     y1,z),
        vfromxyz(lerp(x0,x1,fy),  y1,z),
        vfromxyz(x0,      lerp(y1,y0,fy),z)
      ]),
      name:rc.name
    };
  }
}

function polyFromRect(view,rc) {
	var z=0;
  return {
    points:
      screenPointsToWorld(view,[vfromxyz(rc.start.x, rc.start.y ,z),
      vfromxyz(rc.end.x,   rc.start.y ,z),
      vfromxyz(rc.end.x,   rc.end.y ,z),
      vfromxyz(rc.start.x, rc.end.y ,z)
    ]),
    name:rc.name,
	drawnby:"linetool"
  };
}

function polyOctFromRect(view,rc) {
  var x0 = rc.start.x;
  var y0 = rc.start.y;
  var x1 = rc.end.x;
  var y1 = rc.end.y;
  var t=0.25; // trim a little from the corners
  var z=0;
  return {
    points:screenPointsToWorld(view,[
      vfromxyz(lerp(x0,x1,t),  y0,z),
      vfromxyz(lerp(x1,x0,t),  y0,z),
      vfromxyz(x1,  lerp(y0,y1,t),z),
      vfromxyz(x1,  lerp(y1,y0,t),z),
      vfromxyz(lerp(x1,x0,t),  y1,z),
      vfromxyz(lerp(x0,x1,t),  y1,z),
      vfromxyz(x0,  lerp(y1,y0,t),z),
      vfromxyz(x0,  lerp(y0,y1,t),z),
    ]),
    name:rc.name,
	drawnby:"octtool"
  };
}

function distSquared2d(a,b){
   var dx=b.x-a.x; var dy=b.y-a.y; return dx*dx+dy*dy;
}
var g_snapRadius=6;
var g_snapRadiusEdgeSplitFactor=2;

// any polygon points that are colinear with prev/next deemed extraneous - remove
function trimPolyPoints(poly) {
  var newpoints=[];
  if (poly.points.length<3) {return;}
  var num=poly.points.length;
  for (var i=0; i<num; i++) {
     iprev=(i+num-1)%num;
     inext=(i+1)%num;
     pt=poly.points[i];
     midpoint=vaverage(poly.points[iprev],poly.points[inext]);
     if (distSquared2d(midpoint,pt)>g_snapRadius*g_snapRadius){
       newpoints.push(pt);
     }
  }
  if (newpoints.length!=poly.points.length){
    poly.points=newpoints;
  }
}

function polyFromLine(v0,v1,name){
  return{
    points:[v0,v1],
    name:name,
	drawby:"linetool"
  }
}
function polyFromPoint(v0,name){
  return{
    points:[v0],
    name:name,
	drawnby:"pointtool"
  }
}
function makeQuad(v0,v1,v2,v3,nm){
	var newpoly= {points:[v0,v1,v2,v3],name:nm, drawnby:"polytool"};
	return newpoly;
}
function makeTri(v0,v1,v2,nm){
	var newpoly= {points:[v0,v1,v2],name:nm};
	return newpoly;
}
function fillCircle(context, x,y,r) {
  context.beginPath();
  context.arc(x, y, r, 0, 2*Math.PI);
  context.fill();
}
function vfillcircle(context, v,r) {
  context.beginPath();
  context.arc(v.x, v.y, r, 0, 2*Math.PI);
  context.fill();
}
function vdrawcircle(context, v,r) {
  context.beginPath();
  context.arc(v.x, v.y, r, 0, 2*Math.PI);
  context.stroke();
}

function drawRectOutline(context,start,end){
  context.beginPath();
  context.moveTo(start.x,start.y);
  context.lineTo(end.x,start.y);
  context.lineTo(end.x,end.y);
  context.lineTo(start.x,end.y);
  context.lineTo(start.x,start.y);
  context.stroke();
}
function dragFeedbackCrosshairFull(context){
  drawCrosshairFull(context,viewCursor());
}
function drawPointSnapCrosshair(ctx,viewcursor){
  vt=pickPointAt(viewcursor);
  drawCrosshair(ctx,vt?worldToScreen(viewcursor.view,vt):viewcursor.screenpos,g_snapRadius*2);
  if (vt) { vfillcircle(ctx,vt,g_snapRadius);}
}

function dragFeedbackCrosshair(context){
  drawPointSnapCrosshair(context,viewCursor(),g_snapRadius);
}
function vmoveto(context,v){
	context.moveTo(v.x,v.y);
}
function vlineto(context,v){
	context.lineTo(v.x,v.y);
}
function vrect(ctx,topLeft,bottomRight){
	ctx.moveTo(topLeft.x,topLeft.y);
    ctx.lineTo(bottomRight.x,topLeft.y);
    ctx.lineTo(bottomRight.x,bottomRight.y);
    ctx.lineTo(topLeft.x,bottomRight.y);
    ctx.lineTo(topLeft.x,topLeft.y);
}

function dragFeedbackDragRectSub(context,color,alpha){
    context.globalAlpha=alpha;
    context.fillStyle = color;
    context.beginPath();
	vrect(context,g_dragstartpos,g_mousePos);
    context.fill();
	context.stroke();
}
function dragFeedbackDragRect(context){
	dragFeedbackDragRectSub(context,"red",0.2);
}
function drawFeedbackDragRect(context){
	if (g_dragstartpos){dragFeedbackDragRect(context);}
	else{
		dragFeedbackCrosshairFull(context);
	}
}
function dragFeedbackSelectRect(context){
	if (g_leftmousebutton){
		dragFeedbackDragRectSub(context,"green",0.20);
	}
}
function dragFeedbackMultiSelect(context){
	drawCrosshairFull(context,viewCursor());
	drawFeedbackPickPoint(context);
}

function getSnappedRefPoint(viewcursor){
   vt=pickPointAt(viewcursor);
   return vt?vt:viewcursor.worldpos;
}
function makeDefaultViewport(){
	//todo - transform matrix.
	// interim.. window bounds, centre,scale
	return {
		axis:2,
		hasImage:true,
		screenMin:{x:0, y:0, z:0},
		screenSize:{x:g_width, y:g_height, z:0},
		screenMax:{x:g_width, y:g_height, z:0},
		screenCentre:vfromxyz(g_width*0.5, g_height*0.5, 0.0),
		zoom:g_zoom,
		interestPoint:g_viewCentre
	}
}
function getViewport(spos){
	var vps=getViewportList();
	//reverse order - handle overlays
	for (var i=vps.length-1;i>0; i--){
		var vp=vps[i];
		
		if (spos.x>vp.screenMin.x && spos.x<(vp.screenMin.x+vp.screenSize.x) &&
		spos.y>vp.screenMin.y && spos.y<(vp.screenMin.y+vp.screenSize.y)){
			return  vp;
		}
	}
	return vps[0];
}
function viewCursorAt(spos){
	var vp=getViewport(spos);
	return {
		worldpos:screenToWorld(vp,spos),
		screenpos:spos,
		view:vp
	}
}
function viewCursor(){
	return viewCursorAt(g_mousePos);
}
function viewContext(ctx,view){
	return {context:ctx, view:view};
}
function dragFeedbackLine(context){
	var vc=viewCursor();
//	var vct=viewContext(context,vc.view);
	var vct={context:context, view:vc.view};
	console.log("dfbl");
	if (g_dragstartpos){
		context.globalAlpha=0.75;
		context.strokeStyle = "red";
		context.beginPath();
		context.moveTo(g_dragstartpos.x,g_dragstartpos.y);
		var endpoint=getSnappedRefPoint(viewCursor());
		vctLineTo(vct,endpoint);
		context.stroke();
		drawPointSnapCrosshair(context,vc);
	}
}

function cursorScreenDistSquared(viewcursor, worldpoint){
	return distSquared2d(viewcursor.screenpos,worldToScreen(viewcursor.view, worldpoint));
}
function pickPointAt(vcursor) {
  var vertex=null;
  var minDist2=g_snapRadius*g_snapRadius;
  var pickPointAtSub=function (polys){
    for (var pli=0; pli<polys.length; pli++) {
	  var pl=polys[pli];
      for (var pti=0; pti<pl.points.length; pti++) {
         d2=cursorScreenDistSquared(vcursor, pl.points[pti]);
         if (d2<minDist2){
           minDist2=d2;
           vertex=pl.points[pti];
		 }
       }
	  if (pl.polygons) {pickPointAtSub(pl.polygons,vcursor);}
    }
  }
  pickPointAtSub(g_polys);
  return vertex;
}

function pickOrMakePoint(vcursor){
  var vt=pickPointAt(vcursor);
  if (vt) {return vt;}
  // makes a free point assuming it will be used.
  return vcursor.worldpos;
}

function pickOrMakePointEdgeSplit(vc){
	var pick=pickPolyFeatureAt(vc,g_snapRadius*2);
	if (pick.pickedPoint){
		// if it was an edge split.. perform the split
		if (pick.edge){
			foreachPolygon(function(pl){
				if (PolyHasEdge(pl, pick.edge[0],pick.edge[1])){
					console.log("split edge of "+pl.name);
					splitEdgeOfPoly(pl, pick.edge[0],pick.edge[1], pick.pickedPoint);
				}
			});
		}
		return pick.pickedPoint;
	}
	return vc.worldpos;
}



function IsVisible(pl){
   if (g_showAllPolys){return true;}
   return pl==g_currPoly;
}

function pickPolyAt(viewcursor){
	var picked=pickPolyFeatureAt(viewcursor,100000.0);
	if (picked){
		return picked.poly;
	}
	return null;
}
var g_freeEdgeSplit=true;

function GetEdgeSplitPoint(vs,ve, pt){
	if (!g_freeEdgeSplit){
		return vaverage(evs,eve);
	}
	var edgev=vsub(ve,vs);
	var edgelen=vlength(edgev);
	var edgeAxis=vscale(edgev,1.0/edgelen);
	var dp=vdot(vsub(pt,vs),edgeAxis);
	var edgef=(dp>edgelen)?edgelen:(dp<0.0)?0.0:dp;
	return vmadd(vs,edgeAxis,edgef);
	
}
function pickPolyFeatureAt(viewcursor,maxdist) {
	var picked={
		selPoint:null,
		poly:null,
		edge:null,
		edgeFraction:0.0,
		pickedPoint:null
	};
	var minDist2=sqr(maxdist);
	var edgeSplitRadius = g_snapRadius*g_snapRadiusEdgeSplitFactor;

	var pickPolyFeatureAtSub=function(polys) {
		var pl=null;
		for (var pli=0; pli<polys.length; pli++) {
			if (!IsVisible(pli)){continue;}
			pl=polys[pli];

			// pick the polygon centre?
			centre=polyCentre(pl.points);
			d2=cursorScreenDistSquared(viewcursor,centre);
			if (d2<minDist2 && d2<g_snapRadius*g_snapRadius){
				minDist2=d2;
				picked.edge=null;
				picked.selPoint=null;
				picked.poly=pl;
				picked.pickedPoint=centre;
			}
			// pick polygon Edge?
			for (var pti=0; pti<pl.points.length; pti++) {
				pti1=(pti+1)%pl.points.length;
				var evs=pl.points[pti];
				var eve=pl.points[pti1];
				var edgeSplitPoint=GetEdgeSplitPoint(evs,eve,viewcursor.worldpos);
				var d2s=cursorScreenDistSquared(viewcursor,evs);
				var d2e=cursorScreenDistSquared(viewcursor,eve);
				//reject if the edge's vertices are closer than threshold
				// an edge split would otherwise create an potential exact match
				if (d2s<sqr(g_snapRadius*2) || d2e<sqr(g_snapRadius*2)){
					continue;
				}
//				console.log(JSON.stringify({pt:viewcursor.worldpos,esp:edgeSplitPoint}));
				var d2=cursorScreenDistSquared(viewcursor,edgeSplitPoint);
				//TWEAK: edge-split operations require the cursor closer to the edge- much better on touchscreens
				if (d2<=minDist2 && d2 < edgeSplitRadius*edgeSplitRadius){
					minDist2=d2;
					picked.poly=pl;
					picked.edge=[evs,eve];
					picked.selPoint=null;
					picked.pickedPoint=edgeSplitPoint;
				} 
			}    

			// pick polygon vertex?
			// - must override split edge
			for (var pti=0; pti<pl.points.length; pti++) {
				pt=pl.points[pti];
				var d2=cursorScreenDistSquared(viewcursor,pt);
				if (d2<=minDist2){
					minDist2=d2;
					picked.selPoint=pt;
					picked.poly=pl;
					picked.edge=null;
					picked.pickedPoint=pt;
				}
			}
			// check components...
			if (pl.polygons) {
				pickPolyFeatureAtSub(pl.polygons);
			}
		}
	};
	pickPolyFeatureAtSub(g_polys);
	return picked;
}

function keyDelta(key,dec,inc){
	return (key==dec)?-1:(key==inc)?1:0;
}
function drawNewCrosshair(context,crossHairPos){
	context.fillStyle="black";
	context.globalAlpha=0.25;
	vfillcircle(context,crossHairPos,g_snapRadius);
	context.globalAlpha=0.75;
	context.fillStyle="white";
	drawCrosshair(context,crossHairPos,g_snapRadius*2);
	vdrawcircle(context,crossHairPos,g_snapRadius);
}

function drawFeedbackDrawPolyVertices(vct){
	  vct.context.fillStyle=g_drawFeedbackColor;
	  for (var i=0; i<g_drawingPoly.length; i++){
		vctFillCircle(vct,g_drawingPoly[i],g_snapRadius/2);
	  }
}

function drawFeedbackDrawPoly(context){
	const drawPolyColor=g_drawFeedbackColor;
	var vc=viewCursor();
	var pick=pickPolyFeatureAt(vc,g_snapRadius*2);
//	consolejson(pick);
	var endpt=(pick.pickedPoint)?pick.pickedPoint:pickOrMakePoint(vc);
//	drawPointSnapCrosshair(context,vc,g_snapRadius);todo 'Sub' of this
	var crossHairPos=endpt?worldToScreen(vc.view,endpt):viewcursor.screenpos;
	drawNewCrosshair(context,crossHairPos);

    if (g_drawingPoly.length>0){
      context.globalAlpha=0.75;
      context.strokeStyle = drawPolyColor;;

      if (cursorScreenDistSquared(vc,g_drawingPoly[0])<g_snapRadius*g_snapRadius) {
        endpt=g_drawingPoly[0];
        context.strokeStyle = g_currentPolyOutline;
        context.globalAlpha=1.0;
      }
      context.beginPath();
	  var vct={context:context, view:vc.view};
      vctMoveTo(vct,g_drawingPoly[0]);
      for (var i=1; i<g_drawingPoly.length; i++){
        vctLineTo(vct,g_drawingPoly[i]);
      }
      vctLineTo(vct,endpt);
      context.stroke();

		drawFeedbackDrawPolyVertices(vct);

	  
      context.globalAlpha=0.15;
      context.beginPath();
      vctMoveTo(vct,endpt);
      vctLineTo(vct,g_drawingPoly[0]);
      context.stroke();
    }
    //dragFeedbackCrosshair(context);
}
function drawFeedbackDrawQuadstrip(context){
    if (g_drawingPoly.length>0){
		vc=viewCursor();
		vct={context:context, view:vc.view};
		context.globalAlpha=0.75;
		context.strokeStyle = "red";
		var endpt=pickOrMakePoint(vc);
		context.beginPath();
		var l=g_drawingPoly.length;
		vctMoveTo(vct,g_drawingPoly[0]);
		if (l>1){vctLineTo(vct,g_drawingPoly[1]);
		}
		if (l==1){
		  vctLineTo(vct,endpt);
		}else if (l==2){
		  vctLineTo(vct,endpt);
		  vctLineTo(vct,g_drawingPoly[0]);
		} else if (l==3){
		  vctLineTo(vct,endpt);
		  vctLineTo(vct,g_drawingPoly[2]);
		  vctLineTo(vctt,g_drawingPoly[0]);
		}
		context.stroke();
    }
    dragFeedbackCrosshair(context);
}

function polyCentre(poly){
   var tx=0;
   var ty=0;
   var accum=vzero();
   for (var i=0; i<poly.length; i++){
     vaddto(accum, poly[i]);
   }
   return vscale(accum, 1.0/poly.length);
}

function drawFeedbackPickPolyPoint(ctx) {
	if (isMultiSelect()){
		drawFeedbackSelectTool(ctx);
		return;
	}
	ctx.globalAlpha=0.5;
	picked = g_adjustPoint?g_adjustPoint:pickPolyFeatureAt(viewCursor(),100000.0);
	if (picked.poly) {
		var spos=worldToScreen(viewCursor().view,picked.pickedPoint);
		drawNewCrosshair(ctx,spos);

//		vfillcircle(ctx,spos,g_snapRadius);
	}
}
function drawFeedbackMultiTool(ctx){
	ctx.globalAlpha=0.5;
	var vc=viewCursor();
	var pick=pickPolyFeatureAt(vc, g_snapRadius);
	var vct={context:ctx,view:vc.view};
	var currPoint=pick.pickedPoint?pick.pickedPoint:vc.worldpos;
	var spos=worldToScreen(vc.view, currPoint);
	if (pick){
		drawNewCrosshair(ctx,spos);
	}
	
	if (g_multiToolLastPoint && g_multiToolLastPoint.tag) {
		ctx.strokeStyle=g_drawFeedbackColor;
		ctx.fillStyle=g_drawFeedbackColor;
		vctMoveTo(vct,g_multiToolLastPoint);
		vctLineTo(vct,currPoint);
		ctx.stroke();
	// needs greater feedack of 'last point'
		var spos1=worldToScreen(vc.view, g_multiToolLastPoint);
		vfillcircle(ctx, spos1, g_snapRadius);
	}
   if (g_drawingPoly.length){	
		ctx.strokeStyle=g_drawFeedbackColor;
	  drawFeedbackDrawPolyVertices(vct);
      ctx.globalAlpha=0.15;
      ctx.beginPath();
	  // give some indication that we could fill a poly
      vctMoveTo(vct,currPoint);
      vctLineTo(vct,vlerp(currPoint,g_drawingPoly[0],0.125));
      vctMoveTo(vct,g_drawingPoly[0]);
      vctLineTo(vct,vlerp(g_drawingPoly[0],currPoint,0.125));
      ctx.stroke();
   }

}

function drawFeedbackPickPoint(ctx) {
	ctx.globalAlpha=0.5;
	var pt=pickPointAt(viewCursor());
	if (pt){
		var spos=worldToScreen(viewCursor().view,pt);
		drawNewCrosshair(ctx,spos);
//		vfillcircle(ctx,spos,g_snapRadius);
	}
}
function isDragging(){return g_dragstartpos!=null;}
function drawFeedbackSelectTool(ctx){
//	drawFeedbackPickPolyPoint(ctx);
	if (isDragging()){ drawFeedbackDragRect(ctx);return};
	var vc=viewCursor();
	var pt = pickPointAt(vc);
	if (pt){
		var spos=worldToScreen(viewCursor().view,pt);
		drawNewCrosshair(ctx,spos);
	} else	
		drawCrosshairFull(ctx,vc);
}

function drawCrosshairFull(context,vc){
  var spos=vc.screenpos;
  context.strokeStyle="#ffffff";
  context.globalAlpha=0.25;
  context.beginPath();
  context.moveTo(spos.x, vc.view.screenMin.y);
  context.lineTo(spos.x, vc.view.screenMax.y);
  context.stroke();
  context.beginPath();
  context.moveTo(vc.view.screenMin.x,spos.y);
  context.lineTo(vc.view.screenMax.x,spos.y);
  context.stroke();
}
function drawCrosshairSub(context,cursor,alpha,color,inner,size){
  context.strokeStyle="#ffffff";
  context.globalAlpha=0.5;
  context.beginPath();
  context.moveTo(cursor.x,cursor.y+inner);
  context.lineTo(cursor.x,cursor.y+size);
  context.moveTo(cursor.x,cursor.y-inner);
  context.lineTo(cursor.x,cursor.y-size);
  context.moveTo(cursor.x-inner,cursor.y);
  context.lineTo(cursor.x-size,cursor.y);
  context.moveTo(cursor.x+inner,cursor.y);
  context.lineTo(cursor.x+size,cursor.y);
  context.stroke();
}
function drawCrosshair(context,cursor,size){
	drawCrosshairSub(context,cursor,0.5,"#ffffff",0,size);
}

function drawFeedbackTransformTool(context){
	var vc=viewCursor();
	var centroid=GetSelectedVerticesCentroid()
	//todo this should work per viewport, in 3d views mode
	var spos=worldToScreen(vc.view, centroid);
	drawCrosshairSub(context,spos,0.75, "#ffffff",g_snapRadius*2, g_snapRadius*4.0);
	context.beginPath();
	context.strokeStyle="#ffffff";
	context.globalAlpha=0.75;
	context.arc(spos.x,spos.y, g_snapRadius*2.0, 0,2*Math.PI);
	context.stroke();
	// transform tools can pick points or drag the whole.
	drawFeedbackPickPoint(context);	
}

function drawRotatedText(ctx,txt,x,y,a){
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(a);
  ctx.textAlign = "center";
  ctx.fillText(txt, 0, 0);
  ctx.restore();
}
function drawSaneRotatedText(ctx,txt,x,y,a){
   if (a>3.142*0.5) a-=3.142;
   if (a<-3.142*0.5) a+=3.142;
   drawRotatedText(ctx,txt,x,y,a);
}


function drawStatusInfo(ctx) {
    ctx.font = "10px Arial";
	ctx.textAlign="left";
	ctx.fillStyle=g_currentPolyOutline;

	var text=g_tool.name+"\n";
	vc=viewCursor();
	text+="x="+vc.worldpos.x+" y="+vc.worldpos.y+" z="+vc.worldpos.z;
	ctx.globalAlpha=0.75;
	ctx.fillStyle="#000000";
	ctx.fillText(text,20, 22);
	ctx.fillStyle="#ffffff";
	ctx.fillText(text,20, 20);
}

function drawHrc(context,x,y,polys){
	context.textAlign="left";
	
	for (var i=0; i<polys.length; i++){
		pl=polys[i];
		context.fillText(pl.name, x,y);
		y+=20;
		if (pl.polygons){
			y=drawHrc(context,x+10,y,pl.polygons);
		}
	}
	return y;
}

function getViewportList(){
	if (g_viewMode==0){
		return [makeDefaultViewport()];
	} else if (g_viewMode==1){
		//picture-in-picture zoom
		var vps=[];
		var vp=makeDefaultViewport();
		vps.push(vp);
		vp=makeDefaultViewport();
		vp.screenSize.x*=0.25;
		vp.screenSize.y*=0.25;
		vp.zoom=vp.screenSize.x/g_imageWorldSize.x;
		vp.screenMin.x=vp.screenMax.x - vp.screenSize.x;
		vp.screenMin.y=0;//vp.screenSize.y;
		
		vp.screenMax=vadd(vp.screenMin , vp.screenSize);
		vp.screenCentre=vaverage(vp.screenMin,vp.screenMax);
		vp.interestPoint=vscale(g_imageWorldSize,0.5);
		vps.push(vp);
		return vps;
	}
	else{
		//var vp=makeDefaultViewport();
		var sOfs=vfromxyz(g_width/4,g_height/4,0);
		var smin=vfromxyz(0,0,0);
		var smax=vfromxyz(g_width,g_height,0);
		var vps=[];
		for (var i=0; i<4; i++){
			
			var si=i&1;
			var sj=(i|0)>>1;

			var vpsub=makeDefaultViewport();

			vpsub.axis=i;
			vpsub.hasImage = (vpsub.axis==2)?true:false;

			vpsub.screenSize=vfromxyz(smax.x/2, smax.y/2, 0);
			vpsub.screenMin=vfromxyz(si*(smax.x/2), sj*(smax.y/2), 0);
			vpsub.screenMax=vadd(vpsub.screenMin,vpsub.screenSize);
			vpsub.screenCentre=vadd(vpsub.screenMin,sOfs);
			vpsub.zoom*=0.5;
			vps.push(vpsub);
		}
		return vps;
	}

}
var g_printPos=vzero();
// debug print helpers.
function printAtInCtx(context,x,y,txt){
    context.font = "20px Arial";
    context.fillText(txt,x,y);
	context.stroke();
	g_printPos=vfromxy(x,y+20);
}

function printAt(x,y,txt){
	printAtInCtx(editor.getContext("2d"),x,y,txt);
}
function print(txt){
	printAt(g_printPos.x,g_printPos.y,txt);
}
function printObj(obj){
	printAt(g_printPos.x,g_printPos.y,JSON.stringify(obj));
}
function printObjAt(x,y,obj){
	printAt(x,y,JSON.stringify(obj));
}

function PolyHasPoint(pl,vt){
	for (var plvti=0; plvti<pl.points.length; plvti++){
		if (pl.points[plvti]==vt){
			return true;
		}
	}
	return false;
}
function PolyHasBothVertices(pl,vs,ve){
	for (var plvti=0; plvti<pl.points.length; plvti++){
		var has_vs=false;
		var has_ve=false;
		// 
		for (j=0; j<pl.points.length; j++){
			var pt=pl.points[j];
			if (pt==vs) {has_vs=true;}
			if (pt==ve) {has_ve=true;}
		}
		if (has_vs && has_ve){
			return pl;
		}

	}
	return false;
}
function PolyHasEdge(pl,vs,ve){
	for (var plvti=0; plvti<pl.points.length; plvti++){
		// 
		for (j=0; j<pl.points.length; j++){
			var pt=pl.points[j];
			var pt1=pl.points[(j+1)%pl.points.length];
			if ((pt==vs && pt1==ve)||(pt==ve && pt1==vs)){
				return true;
			}
		}
	}
	return false;
}

function doesEdgeSplitPolySub(polys,vs,ve){
	var i=0;
	for (i=0; i<polys.length; i++){
		var pl=polys[i];
		var j;
		if (PolyHasBothVertices(pl, vs,ve)){
			return pl;
		}
		if (pl.polygons){ 
			var subpl=doesEdgeSplitPolySub(pl.polygons,vs,ve);
			if (subpl){
				return subpl;
			}
		}
	}
	return null;
}

function DoesEdgeSplitPoly(vs,ve){
	var ret=doesEdgeSplitPolySub(g_polys,vs,ve);
	return ret;
	
}

var g_rawImage = new Uint8ClampedArray(256 * 256 * 4);
for (var j=0; j<256; j++) {
	for (var i=0; i<256;i++){
		g_rawImage[(i+j*256)*4+0]=i;
		g_rawImage[(i+j*256)*4+1]=j;
		g_rawImage[(i+j*256)*4+2]=i-j;
		g_rawImage[(i+j*256)*4+3]=((i&15)+(j&15))*16;
	}
}
function imageFromArray(buffer,width,height){
	var tmpCanvas=document.createElement("canvas");
	var ctx=tmpCanvas.getContext("2d");
	tmpCanvas.width=width;
	tmpCanvas.height=height;
	var idata=ctx.createImageData(width,height);
//there must be a better way?!
//	idata.data.splice(0,0,buffer.slice(0,width*height*4));
	for (var i=0; i<width*height*4;i++){ idata.data[i]=buffer[i];}
	ctx.putImageData(idata,0,0);
	
	var img= new Image();
	img.src=tmpCanvas.toDataURL();
	img.onload=function(){console.log("tmp image loaded."+img.width+" "+img.height)};
	// debug- show it
	console.log("created image."+img.width+" "+img.height);
	return img;
}
var g_myimg= imageFromArray(g_rawImage,256,256);

function ShowMaskedImages(){
	// generate mask for each polygon, create an image buffer, 
	// assemble into a page, and show it.
	var url=window.URL.createObjectURL(new Blob(["hello world"]));
	window.open(url,"w2");
	//document.getElementById("genImages").appendChild(g_myimg);
}

function repaint(){
  var canvas = document.querySelector("canvas");
  var context = canvas.getContext("2d");
  context.canvas.width  =window.innerWidth;
  context.canvas.height =window.innerHeight;
  var vps=getViewportList();
	for (var i=0; i<vps.length; i++){
		repaintView(context,vps[i]);
	}
}
function vctDrawAxialCross(vct,pos,size)
{
   vct.context.beginPath();
   vctMoveTo(vct, vfromxyz(pos.x-size, pos.y, pos.z));
   vctLineTo(vct, vfromxyz(pos.x+size, pos.y, pos.z));
   vctMoveTo(vct, vfromxyz(pos.x, pos.y-size, pos.z));
   vctLineTo(vct, vfromxyz(pos.x, pos.y+size, pos.z));
   vctMoveTo(vct, vfromxyz(pos.x, pos.y, pos.z-size));
   vctLineTo(vct, vfromxyz(pos.x, pos.y, pos.z+size));
   vct.context.stroke();
}
function repaintView(context,vp) {
	context.save();
	context.beginPath();
	context.rect(vp.screenMin.x,vp.screenMin.y, vp.screenSize.x,vp.screenSize.y);
	context.stroke();
	context.clip();
  if (!g_img.ready) {
    
    context.font = "20px Arial";
    context.fillText("loading\n"+g_img.src,0,0);

    return;
  }
	var vct={context:context,view:vp};
//draw backgrounda
	context.globalAlpha=1.0;
	var img=g_img;
  //todo- transform and clip the image..
  var imgMin=vfromxyz(0,0,0);
  var imgMax=g_imageWorldSize;//vfromxyz(g_scaled_w,g_scaled_h,0);
  var sImgMin=worldToScreen(vp,imgMin);
  var sImgMax=worldToScreen(vp,imgMax);
  var sSize=vsub(sImgMax,sImgMin);
  context.fillStyle="#808080";
  context.clearRect(vp.screenMin.x, vp.screenMin.y, vp.screenSize.x, vp.screenSize.y);
  if (vp.hasImage){
	  context.drawImage(img,0,0,img.width,img.height,
		sImgMin.x,sImgMin.y, sSize.x, sSize.y);
	}
 // draw world axes..
   var vct={context:context,view:vp};
   context.globalAlpha=0.25;
   context.strokeStyle="#000000"
   vctDrawAxialCross(vct,vzero(),10000.0);

   

//  if (g_currentPoly>g_polys.length){currentPoly=-1;}
  drawPolygons(context,vp,g_polys,null,false);
//  drawHrc(context,50,50,g_polys);

   // draw InterestPoint
   context.strokeStyle="#ffffff"
   context.globalAlpha=0.2;
   vctDrawAxialCross(vct,g_viewCentre,20.0/vp.zoom);

  
  // show current tool feedback, unless it's pinch-zooming
  if (g_tool && !isMultiTouch()){
		if (g_tool.drawfeedback){g_tool.drawfeedback(context);}

  }
  if (g_cursorTxt){
	 context.globalAlpha=0.5;
	  context.fillStyle = "white";
    context.font = "15px Arial";
        context.textAlign="left";
        context.fillText(g_cursorTxt, g_mousePos.x,g_mousePos.y+30);
	
	g_cursorTxt=null;
  }
  // show view type
  {
	context.globalAlpha=0.5;
	context.fillStyle = "white";
	context.fillText(g_axisName[vp.axis],vp.screenMin.x+15,vp.screenMin.y+15);
  }
  drawStatusInfo(context);
  context.restore();
}

function drawPolygons(context,vp,polys,parent,sel){
  var vct=viewContext(context,vp);
  vct.context=context;

  context.globalAlpha=0.5;
  context.fillStyle = "green";
  context.strokeStyle="#00ff00";
  var textHeight;
  if (g_polys.length<8){
    textHeight=20.0;
    context.font = "20px Arial";
  } else if(polys.length<16){
    textHeight=15.0;
    context.font = "15px Arial";
  }else{
    textHeight=10.0;
    context.font = "10px Arial";
  }

  // Show polys
  for (var pli=0; pli<polys.length; pli++){
    if (!IsVisible(pli)) continue;
    pl=polys[pli];

    // account for selection in rendering style.
    currentPolyOutlineColor = (pl==g_currPoly || sel)?g_currentPolyOutline:pl.color;

    // fill the area
    context.globalAlpha=0.25;
    if (pl.points.length>2){
      context.beginPath();
      vctMoveTo(vct,pl.points[pl.points.length-1]);
      for (var j=0; j<pl.points.length; j++) {
        vctLineTo(vct,pl.points[j]);
      }
      context.closePath();
      context.fillStyle = pl.color;
      context.fill();
    }
	
    context.globalAlpha=0.75;
    context.fillStyle=currentPolyOutlineColor;
    if (g_showVertices){
	  var tags=0;
      for (var j=0; j<pl.points.length; j++) {
		vt=pl.points[j];
		size=vt.tag?g_snapRadius:g_snapRadius/2;
        vfillcircle(context,worldToScreen(vp,pl.points[j]),size);
      }
    }

    // get the centroid
    pos=worldToScreen(vp,polyCentre(pl.points));
    // stroke the outline
    context.strokeStyle = currentPolyOutlineColor;
    context.globalAlpha=0.75;
    context.beginPath();

    if (pl.points.length==1){ // it's a single-point crosshair
      
      context.moveTo(pos.x-g_snapRadius*2,pos.y);
      context.lineTo(pos.x+g_snapRadius*2,pos.y);
      context.stroke();
      context.moveTo(pos.x,pos.y-g_snapRadius*2);
      context.lineTo(pos.x,pos.y+g_snapRadius*2);
      context.stroke();
    }
    else if  (pl.points.length>1){
	    vctMoveTo(vct,pl.points[pl.points.length-1]);
		for (var j=0; j<pl.points.length; j++) { // it's a prpper poly.
			vctLineTo(vct,pl.points[j]);
		}
	}
   
    context.stroke();
    // draw the label name.
    context.globalAlpha=0.75;
    if (g_showLabelNames){
      var textWidth = context.measureText(pl.name).width;
   
// text label black background
//       context.globalAlpha=(pli==g_currentPoly)?0.5:0.25;
//      context.fillStyle = "black";
//      context.fillRect(pos.x-textWidth/2,pos.y-textHeight/2, textWidth, textHeight);
      context.globalAlpha=(pl.tag ||(pl==g_currPoly))?1.0:0.75;
      context.fillStyle = g_labelColor;
      if (pl.points.length==2){
         drawSaneRotatedText(context,pl.name, pos.x,pos.y, Math.atan2(pl.points[1].y-pl.points[0].y, pl.points[1].x-pl.points[0].x))
      } else{
        context.textAlign="center";
        context.fillText(pl.name,pos.x,pos.y);
      }
    }
	// does this polygon have components..
	if (pl.polygons){
		drawPolygons(context,vp,pl.polygons,pl,sel||(pl==g_currPoly));
	}
  }
}


function getCurrentLabel(){
// get the entered label and cache it.
	var val= document.getElementById("currentLabel").value; g_presetLabels[g_presetLabelIndex]=val; return val;}
function setCurrentLabel(newval){document.getElementById("currentLabel").value=newval;}

function IncWrap(val,inc,max){
  if (max==0) return 0;
  var next=val+inc;
  if (next<0)next+=max;  
  return next%max;
}
function TogglePresetLabel(dir){
  g_presetLabelIndex=IncWrap(g_presetLabelIndex,dir,g_presetLabels.length);
  setCurrentLabel(g_presetLabels[g_presetLabelIndex]);
}
function ToggleCurrentPoly(dir){
  if (!g_polys.length){return;}
  if (!g_currPoly){
    g_currPoly=g_polys[0];
  }
  var pls = getListContainingPoly(g_currPoly,g_polys);
  var i=getIndexOfPoly(pls,g_currPoly);
  i+=dir;
  if (i<0){i=pls.length-1;}
  else if (i>=pls.length){i=0;}
  g_currPoly=pls[i];
  repaint();
}

function SetCursor(type){
//	editor.style.cursor=type;//"url(crosshair.png), auto";
}
// rectangular-drag creation tools -
// several variations for different actual shapes

function makeRectToolVariant(polyCreateFn,txt){
  return{
	
	drawfeedback:drawFeedbackDragRect,
	name:txt,
    activate: function(e){
		SetCursor("crosshair");
    },
    mousepassivemove: function(e){
    },
    mousedrag: function(e){
    },
    mouseclickup:function(e){
	},
    mousedragend:function(e){
		if (g_dragstartpos){
			newrect={start:g_dragstartpos,end:g_mousePos,name: getCurrentLabel()};

			if (distSquared2d(g_dragstartpos,g_mousePos)>0){
			  AddPoly(polyCreateFn(viewCursor().view,newrect));
			}
		}
    }
  }
}

g_hexTool=makeRectToolVariant(polyDiagonalHexFromRect,"draw diagonal hexagon");
g_octTool=makeRectToolVariant(polyOctFromRect,"draw octagon");
g_rectTool=makeRectToolVariant(polyFromRect,"draw rect");

function addChild(parent,pl){
	console.log("set parent:"+parent.name+"->"+pl.name);
	if (!parent.polygons){
		parent.polygons=[];
	}
	parent.polygons.push(pl);

}

function dumpHrc(pls,indent){
	for (var i=0; i<pls.length; i++){
		var pl=pls[i];
		var str=""; for (var j=0; j<indent; j++){str+="\t";}
		console.log(str+pl.name);
		if (pl.polygons){dumpHrc(pl.polygons, indent+1);}
	}
}
g_parentTool={
	name:"set object parents (pick parts)",
	drawfeedback:function(ctx){
		drawFeedbackPickPolyPoint(ctx);
		ctx.fillText(g_mousePos.x,g_mousePos.y+20,
			(!g_currPoly)?"pick parent":"pick part of"+g_currPoly.name
		);
	},
	activate: function(e){ g_currPoly=0;},
	mousepassivemove:function(e){
		g_cursorTxt = !g_currPoly?"pick parent":"pick part of "+g_currPoly.name
	},
	mouseclickup:function(e){
		console.log("change hrc: before:- "+g_polys.length);
		dumpHrc(g_polys,0);
		var poly=pickPolyAt(viewCursor());
		if (!g_currPoly){g_currPoly=poly; repaint();}
		else if (g_currPoly && poly){
			if(!isParentOf(g_currPoly,poly) && poly!=g_currPoly){
				pls=getListContainingPoly(poly);
				removeFromArray(pls,poly);
				addChild(g_currPoly,poly);
			}
		}
		console.log("after:-"+g_polys.length);
		dumpHrc(g_polys,0);
		console.log("done");
	}
};
function lastIsNot(array,x){
	if (array.length==0) {return true;}
	return (array[array.length-1]!=x);
}

// lasso tool ... better for touchscreens? 

var g_lassoStepDist=30;
var g_lassoDrawMaxPoints=32;
if (!Array.prototype.last){
	Array.prototype.last=function(){return this.length>0?this[this.length-1]:null;};
}

g_lassoDrawTool={
	name:"draw-lasso tool",
	drawfeedback:drawFeedbackDrawPoly,
	activate: function(e){g_drawingPoly=[]; SetCursor("crosshair");},
	mousedrag:function(e){
		var vc=viewCursor();
		if (!g_drawingPoly.length){
			g_drawingPoly.push(vc.worldpos);
		} else{
			var lastpt=g_drawingPoly[g_drawingPoly.length-1];
			var drawdir=vsub(vc.worldpos,lastpt);
			var mouseWorldDelta=screenDeltaToWorld(viewCursor(),g_mouseScreenDelta);

			if (vdistSquared(worldToScreen(vc.view,lastpt),g_mousePos)>sqr(g_lassoStepDist) || vdot(drawdir, mouseWorldDelta)<0){
				g_drawingPoly.push(vc.worldpos);
			}
		}
	},
	mousedragend:function(e){
		// make an approx poly from it
		if (!g_drawingPoly.length) {return;}
		while (g_drawingPoly.length>g_lassoDrawMaxPoints){
			var bestscore=100000000.0;
			var besti=-1;
			// find the straightest 2 points,
			var i;
			for (i=0; i<g_drawingPoly.length;i++){
				var iprev=i?i-1:g_drawingPoly.length-1;
				var inext=(i+1)%g_drawingPoly.length;
				var dist01=vlengthBetween(g_drawingPoly[iprev],g_drawingPoly[i]);
				var dist12=vlengthBetween(g_drawingPoly[inext],g_drawingPoly[i]);
				var dist02=vlengthBetween(g_drawingPoly[inext],g_drawingPoly[iprev]);
				// how linear is it? if dist02=dist01+dist12, it's perfect. the higher, the worse
				var score=((dist01+dist12)-dist02)/dist02;
				if (score<bestscore){
					bestscore=score;
					besti=i;
				}
			}
			// remove besti
			console.log("remove vertex "+besti+" of "+g_drawingPoly.length);
			g_drawingPoly.splice(besti,1);
		}
		AddPoly({points:g_drawingPoly,name:getCurrentLabel(),drawnby:"lasso"});
		g_drawingPoly=[];
	},
	cancel:function(e){
      g_dragstartpos=null;//g_mousePos;
		g_drawingPoly=[];
	}
}

g_dragLineTool={
	name:"deprecated draw edges",
	activate: function(e){
		g_drawingPoly=[];
		SetCursor("crosshair");
		return true;
	},
	drawfeedback:drawFeedbackDrawPoly,

  mousedown: function(e){
  },
  
  mouseclickup:function(e){
	console.log("drawline mouse click up");
//	g_dragstartpos=null;	// cancel drag.
	var ept=pickOrMakePoint(viewCursor());
	if (g_drawingPoly.length){
		if (vdistSquared(g_drawingPoly[g_drawingPoly.length-1],ept)<0.00001)
			return;
	}
	g_drawingPoly.push(ept);
	if (g_drawingPoly.length==2){
		AddEdgeMaybeSplitPoly(g_drawingPoly[0],g_drawingPoly[1]);
		// todo - linestrip mode.. right-click??
		g_drawingPoly=[];
	}
/*	  if (g_dragstartpos){
	      if (distSquared2d(g_mousePos,g_dragstartpos)>0){
		    vstart=pickOrMakePoint(viewCursorAt(g_dragstartpos));
			vend=pickOrMakePoint(viewCursor());
		    AddPoly({points:[vstart,vend], name:getCurrentLabel(),drawnby:"linedraw"});
				
			
		  }
		  t
		}
*/
		//g_drawfeedback=dragFeedbackCrosshair;
  },
  mousedragend:function(e){
	g_drawingPoly=[];
      
  },
  cancel:function(){
      g_dragstartpos=null;//g_mousePos;
		g_drawingPoly=[];
  }
};


function makeDrawToolVariant(_name,drawFn,rclickfn){
	var tool={
		name:_name,
		drawfeedback:drawFeedbackDrawPoly,
		activate: function(e){
			g_drawingPoly=[];
			SetCursor("crosshair");
			return true;
		},
		mousedown:function(e){},
		mouseclickup:drawFn,
		mousedragend:function(e){
		},
		mouserightclick:rclickfn,
		cancel:function(){
		g_dragstartpos=null;//g_mousePos;
		 g_drawingPoly=[];
		}
	};
	return tool;
}

function TranslateVerticesByDrag(fn){
	var worldDelta=screenDeltaToWorld(viewCursor(),g_mouseScreenDelta);
	vtc=GetSelectedVertices();
	vtc.forEach(function(val,vt,map){
		vaddto(vt,worldDelta);
	});
}
function RotateVerticesByDrag(fn){
	// todo: multi-transform tool based on gadgets
	// rotation handle, centre drag, corner scaling.

	vc=viewCursor();
	var worldDelta=screenDeltaToWorld(vc,g_mouseScreenDelta);
	var selv=GetSelectedVertices();
	var centroid=GetVertexMapCentroid(selv);
	var num=0;

	// into screenspace
	var sCentroid = worldToScreen(vc.view,centroid);
	var sCursorOfs=vsub(g_mousePos, sCentroid);
	var dx=sCursorOfs.x;
	var dy=sCursorOfs.y;
	var dlen=Math.sqrt(dx*dx+dy*dy);
	var invdlen=1.0/dlen;
	var dr=(dy*g_mouseScreenDelta.x-dx*g_mouseScreenDelta.y)*invdlen;
	var incAngle=Math.atan(dr/dlen);
	var c=Math.cos(incAngle),s=Math.sin(incAngle);
	// todo, make a propper rotation matrix.

	selv.forEach(function(val,vt,map){
		var ofs=vsub(vt,centroid);
		
		vt.x=centroid.x+ofs.x*c+ofs.y*s;
		vt.y=centroid.y-ofs.x*s+ofs.y*c;
		vt.z=centroid.z+ofs.z;
	});
}

function ScaleVerticesByDrag(fn){
	console.log("ScaleVerticesByDrag");
	// todo: multi-transform tool based on gadgets
	// rotation handle, centre drag, corner scaling.

	vc=viewCursor();
	var worldDelta=screenDeltaToWorld(vc,g_mouseScreenDelta);
	var selv=GetSelectedVertices();
	var centroid=GetVertexMapCentroid(selv);
//	var extents=GetVertexMapExtents(selv);	-todo, corner scaling
	var num=0;
	var ofs = vsub(vc.worldpos, centroid);
	// weird tweak: to stop violent scaling,
	// make all axis deltas relative to the longest feature
//	var ofsmax=Math.max(Math.max(ofs.x,ofs.y),ofs.z);
	ofsmax=100.0;
// direction of scaling rel to gadget
	var f=function(a,b,c){ 
		if (b>c){
			return a;
		} else {
			return -a;
		}
	};
	var sx = (f(worldDelta.x,vc.worldpos.x,centroid.x)+ofsmax)/ofsmax;
	var sy = (f(worldDelta.y,vc.worldpos.y,centroid.y)+ofsmax)/ofsmax;
	var sz = (f(worldDelta.z,vc.worldpos.z,centroid.z)+ofsmax)/ofsmax;
	
	var sfv=vfromxyz(sx,sy,sz);//scale factor vector
	console.log(JSON.stringify([centroid,worldDelta,vc.worldPos,sfv]));

	// todo - use a propper transformation matrix

	selv.forEach(function(val,vt,map){
		var ofs=vsub(vt,centroid);
		var tpos=vadd(centroid,vmulElem(ofs,sfv));
		vt.x=tpos.x;		
		vt.y=tpos.y;		
		vt.z=tpos.z;		
	});

}


function makeTransformToolVariant(_name,transFn,rclickfn){
	tool={
		name:_name,
		drawfeedback:drawFeedbackTransformTool,
		activate:function(e){
			SetCursor("move");
			return true;
		},
		passivemove:function(e){
			console.log("transform passive move");
		},
		mouseclickup:function(e){
			ToggleVertexTag();
		},
		mousedrag:function(e){
			console.log("transform drag");
			transFn();
		}
	}
	return tool;
}

g_translateTool=makeTransformToolVariant("translate",TranslateVerticesByDrag,null);
g_rotateTool=makeTransformToolVariant("rotate",RotateVerticesByDrag,null);
g_scaleTool=makeTransformToolVariant("scale",ScaleVerticesByDrag,null);

g_polyTool=makeDrawToolVariant(
	"polygon",
	function(e){
		console.log("add poly point");
		if (g_drawingPoly.length>2){
			if (cursorScreenDistSquared(viewCursor(),g_drawingPoly[0])<sqr(g_snapRadius)){
				console.log("finish poly by click");
				AddPoly({points:g_drawingPoly,name:getCurrentLabel(),drawnby:"polytool"});
				g_drawingPoly=[];
				return;
			}
		}
		
		g_drawingPoly.push(pickOrMakePointEdgeSplit(viewCursor()));
	},
	function(e){
		console.log("finish poly by rclick");
		g_drawingPoly.push(pickOrMakePoint(viewCursor()));
		AddPoly({points:g_drawingPoly,name:getCurrentLabel(),drawnby:"polytool"});
		g_drawingPoly=[];
	}
);
function AddEdgeMaybeSplitPoly(vstart,vend){
	// it might split many polys.
	var pl=DoesEdgeSplitPoly(vstart,vend);
	// either add an edge or a polygon
	if (pl){
		console.log("splitting poly by new edge -"+pl.name+" vertices="+pl.points.length);
		SplitPolyByEdge(pl,vstart,vend);
	} else {
		console.log("adding new edge as object\n");
		AddPoly({points:[vstart,vend], name:getCurrentLabel(),drawnby:"edgesplit"});
	}
}

g_lineTool=makeDrawToolVariant(
	"draw edge",
	function(e){
		console.log("add draw point");
		g_drawingPoly.push(pickOrMakePointEdgeSplit(viewCursor()));
		if (g_drawingPoly.length==2){

			AddEdgeMaybeSplitPoly(g_drawingPoly[0],g_drawingPoly[1]);
			g_drawingPoly=[];
		}
	},
	function(e){
		console.log("finish poly by rclick - continue line strip");
		g_drawingPoly.push(pickOrMakePointEdgeSplit(viewCursor()));
		AddEdgeMaybeSplitPoly(g_drawingPoly[0],g_drawingPoly[1]);
//		AddPoly({points:g_drawingPoly,name:getCurrentLabel()});
		g_drawingPoly[0]=g_drawingPoly[1];
	}
);


g_quadstripTool=makeDrawToolVariant("quadstrip",function(e){
//  g_drawfeedback=drawFeedbackDrawQuadstrip;
  console.log("add quadstrip point");
  g_drawingPoly.push(pickOrMakePoint(viewCursor()));
  if (g_drawingPoly.length==4){
//	if (distSquared2d(g_mousepos,g_drawingPoly[0])<g_snapRadius*g_snapRadius){
	var vt0=g_drawingPoly[0];
	var vt1=g_drawingPoly[1];
	var vt2=g_drawingPoly[2];
	var vt3=g_drawingPoly[3];
	  console.log("add quadstrip poly..");
	  // if given degeneracy.. make a tri
	  if (vt2==vt3){
		  AddPoly(makeTri(vt0,vt1,vt3,getCurrentLabel()));
		  g_drawingPoly=[vt2];
	  }
	  else
	  if (vt1==vt3){
		  AddPoly(makeTri(vt0,vt2,vt3,getCurrentLabel()));
		  g_drawingPoly=[vt3];
	  }else
		  AddPoly(makeQuad(vt0,vt1,vt2,vt3,getCurrentLabel()));
	  g_drawingPoly=[vt3,vt2];
	  return;
	}
  },
  function(e){g_drawingPoly=[];}
);


g_adjustPoint=null;

g_pointTool={
	name:"draw points",
	drawfeedback:dragFeedbackCrosshair,
	activate:function(e){
		g_adjustPoint=null;
		SetCursor("crosshair");
	},
	mousedown: function(e){},
	mouseclickup: function(e){
		console.log("add  point");
		pt=pickOrMakePoint(viewCursor());
		AddPoly(polyFromPoint(pt,getCurrentLabel()));
	},
	mousedragend: function(e){
	},
	mousepassivemove: function(e){
	},
	mousedrag: function(e){
	}
};

function splitEdgeOfPoly(poly, v0,v1, vmid) {
	console.log("splitEdgeOfPoly");
	// 2 types of edgeplit, if the poly is just an edge, make 2 polys with new vertex
	// else split in the boundary
	if (poly.points.length==2){
	    if ((poly.points[0]==v0 && poly.points[1]==v1) || (poly.points[1]==v0 && poly.points[0]==v1) ) {
			console.log("splitEdgeOfPoly-do edge split of"+poly.name);
			
			//var splitpoly=g_adjustPoint.poly;
			poly.points[0]=v0;
			poly.points[1]=vmid;
			AddPoly( polyFromLine(vmid,v1, poly.name));
		}
	} else{
		for (var i=0; i<poly.points.length; i++) {
			var i1 =(i+1) % poly.points.length;
			if (poly.points[i]==v0 && poly.points[i1]==v1 || poly.points[i]==v1 && poly.points[i1]==v0) {
				console.log("splitEdgeOfPoly - do polyedge split");
				poly.points.splice(i1,0, vmid);
				break;
			}
		}
	}
}

function getIndexOfPoint(poly,pt){
	for (var i=0; i<poly.points.length; i++) {
		if (poly.points[i]==pt)
			return i;
	}
	return -1;
}
function getIndexOfPoly(polys,pl){
	for (var i=0; i<polys.length; i++) {
		if (polys[i]==pl)
			return i;
	}
	return -1;
}
function ClearVertexSelectionTags(){
	foreachVertexOfPolygon(function(vt,pl){
		vt.tag=false;
	});
}

g_selectTool={
	name:"select",
	drawfeedback:drawFeedbackSelectTool,
	activate:function(e){
		SetCursor("default");
	},
	mousepassivemove: function(e){
		multiSelectPassiveMouseMove(e);
	},
	mousedrag: function(e){
		multiSelectMouseMove(e);
	},
	mousedown: function(e){
		multiSelectMouseDown(e);
	},
	mouseclickup:function(e){
		multiSelectMouseClickUp(e);
	},
	mousedragend: function(e){
		multiSelectMouseDragUp(e);
	},
	cancel: function(){
		g_adjustPoint=null;
	}
};

function GetVertexMap(){
	var vm=new Map();
	foreachVertexOfPolygon(function(vt,pl){
		vm.set(vt,true);
	});
	return vm;
}

function foreachVertexSub(polys,f){
	for (var i=0; i<polys.length;i++){
		var pl=polys[i];
		for (var j=0; j<pl.points.length; j++){
			f(pl.points[j])
		}
		if (pl.polygons){foreachVertexSub(pl.polygons,f);}
	}
}
function foreachVertex(f){
	foreachVertexSub(g_polys,f);
}

function foreachVertexOfPolygonSub(polys,f){
	for (var i=0; i<polys.length;i++){
		var pl=polys[i];
		for (var j=0; j<pl.points.length; j++){
			f(pl.points[j],pl);
		}
		if (pl.polygons){
			foreachVertexOfPolygonSub(pl.polygons,f);
		}
	}
}

function foreachVertexOfPolygon(f){
	foreachVertexOfPolygonSub(g_polys,f);
}

function foreachEdgeOfPolygonSub(polys,f){
	for (var i=0; i<polys.length;i++){
		var pl=polys[i];
		for (var j=0; j<pl.points.length; j++){
			f(pl.points[j],pl.points[(j+1)%pl.points.length],pl);
		}
		if (pl.polygons){foreachEdgeOfPolygonSub(pl.polygons,f);};
	}
}

function foreachEdgeOfPolygon(f){
	foreachEdgeOfPolygonSub(g_polys,f);
}

function Extrude(){
	ExtrudeTaggedVertices();
	// todo- 'push tool' sets yet another sub UI mode?
	SetTool(g_translateTool);
}

function ExtrudeTaggedVertices(){
	console.log("extrude");
	var extrudeEdges=[];
	var exvs=new Map();
	var extrudedv=new Map();
	foreachPolygon(function(pl){
		// todo - full poly extrusion logic.
		for (var j=0; j<pl.points.length; j++){
			var va=pl.points[j];
			var vb=pl.points[(j+1)%pl.points.length];
			if (va.tag && vb.tag){
				var edge={start:va, end:vb, poly:pl};
				extrudeEdges.push(edge);
				exvs.set(va,true);
				exvs.set(vb,true);
			}
		}
	});
	console.log("extruded edges count="+extrudeEdges.length+"\n"+
		"extruded vertices count"+extrudedv.length);

	// make the extruded vertices
	var exvi=0;
	foreachVertex(function(v){
		// foreach vertex can hit vertices multiple times!
		if (exvs.has(v) && !extrudedv.has(v)){
			vt=cloneVertex(v); vt.tag=true;
			extrudedv.set(v,vt);
			v.tag=false;
		}
		exvi+=1;
		v.tag=false;
	});
	var exvstr=""
	extrudedv.forEach
	// connect polys for extrusions
	for (var i=0; i<extrudeEdges.length; i++){
		var e=extrudeEdges[i];
		console.log("extruded edge:"+JSON.stringify(e));
		newpoly=makeQuad(e.start,extrudedv.get(e.start),extrudedv.get(e.end),e.end,e.poly?e.poly.name:"");
		newpoly.color = e.poly?e.poly.color:0x808080;
		AddPoly(newpoly);
	}
	console.log("extrude edges "+ extrudeEdges.length +" vertices="+extrudedv.length);
	for (var i=0; i<extrudedv.length; i++){
		
	}
}

function screenDeltaToWorld(vc,ofs){
	return vscale(vchooseAxesInv(ofs,vc.view.axis),1.0/vc.view.zoom);
}
//todo - in perspective views, account for dist ..
function screenDeltaToWorldAt(vc,screenDelta /*, atWorldPos*/){
	return screenDeltaToWorld(vc,screenDelta);
}
// distance from the cursor in a viewport to a world point

function ToggleVertexTag(){
	var pt=pickPointAt(viewCursor());
	if (pt){
		pt.tag=pt.tag?false:true;
	}
}

g_extruded=false;
g_extrudeTool={
	name:"extrude",
	drawfeedback:drawFeedbackPickPoint,
	activate:function(e){
		console.log("extrude tool");
		g_mouseScreenDelta=vzero();
		SetCursor("move");
		g_extruded=false;
	},
	mousedrag: function(e){
		if (!g_extruded){
			console.log("extrude step..");
			ExtrudeTaggedVertices();
			g_extruded=true;
		}
		TranslateVerticesByDrag();
	},
	mousepassivemove: function(e){
/*		vtc=GetSelectedVertices();
//		console.log("selvtc len=",vtc.length+"mousedelta="+JSON.stringify(g_mouseScreenDelta));
		worldDelta=screenDeltaToWorld(viewCursor(),g_mouseScreenDelta);
		vtc.forEach(function(val,keypt,map){
			
			vaddto(keypt,worldDelta);
		});
*/
	},
	mouseclickup: function(e){
		ToggleVertexTag();
	},
	mousedragend: function(e){
		//PopToolOr(g_selectTool); mechanism for restore
		g_extruded=false;},
	mousedown: function(e){
	},
	cancel: function(e){
		PopToolOr(g_selectTool);
	}
}

g_multiSelectDrag=false;
function multiSelectMouseMove(e) {
//	console.log("multi select mouse move,tool=",g_tool.name);
	g_drawfeedback=dragFeedbackSelectRect;
}
function multiSelectPassiveMouseMove(e) {
//	console.log("multi select mouse move,tool=",g_tool.name);
	g_drawfeedback=dragFeedbackMultiSelect;
}
function inrange(a,lo,hi){return a>=lo && a<=hi;}

function multiSelectMouseClickUp(e){
//	console.log("multiselect mouse click up");
	multiSelectTagPoint(e);
	g_multiSelectDrag=false;
}
function multiSelectMouseDragUp(e){
//	console.log("multi select mouse drag up\n");
	var selectedVertices=new Map();
	foreachVertex(function(v){selectedVertices.set(v,true);});
	vc=viewCursor();
	pmin=vmin(g_dragstartpos,g_mousePos);
	pmax=vmax(g_dragstartpos,g_mousePos);
	console.log("bounds:"+JSON.stringify([pmin,pmax]));
	selectedVertices.forEach(function(val,vt,map){
		var spos=worldToScreen(vc.view, vt);
		if (inrange(spos.x, pmin.x,pmax.x) && inrange(spos.y,pmin.y,pmax.y)){
			vt.tag=vt.tag?false:true
		}
	});
	g_multiSelectDrag=false;
	g_dragfeedback=null;
	if (g_tool.cancel){
		g_tool.cancel();
	}
}

function multiSelectMouseDown(e) {
	console.log("multi select click\n");
/*    var pick=pickPolyFeatureAt(viewCursor(),100000.0);
    if (pick.poly){
      g_currPoly=pick.poly;
      g_adjustPoint=pick;
      if (pick.point){
        console.log("move point..");
      }
    }
*/
	var pt=pickPointAt(viewCursor());
	if (pt) {
		if (pt && pt.tag) {g_hackMoveTaggedVertices=true;}
	} else{
		g_multiSelectDrag=true;
	}
	
}
function multiSelectTagPoint(e){
	var pt=pickPointAt(viewCursor());
/*	if (!pt){
        console.log("MSTP didn't find point\n");
		g_hackMoveTaggedVertices=false;
		if (g_adjustPoint){
			if (g_adjustPoint.selPoint){
				pt=g_adjustPoint.selPoint;
			}
		}
	}
*/	if (pt){
//        console.log("MSMD tag a point..\n");
		pt.tag=(pt.tag)?false:true;
	}
}

// multi-tool not exactly the same as adjust-split,
// in that the 'open clicks' behave differently.
// edge-split happens on click
// open clicks make new vertices for line drawing.
// it's really more like the line-draw tool with added vertex-dragging
var g_multiToolLastPoint=null;
g_multiTool={
	name:"drag-adjust vertices, drag-edgesplit, and draw edges from tag",
  activate:function(e){g_multiToolLastPoint=null; g_drawingPoly=[];},
  drawfeedback:drawFeedbackMultiTool, 
  mousedown: function(e){
	console.log("multitool click");
/*	if (!g_multiToolLastPoint){
		g_multiToolLastPoint=pickPointAt(vc);
		if (g_multiToolLastPoint){
			g_multiToolLastPoint.tag=true;
		}
	}
*/
//	if (!isMultiSelect()){
//		ClearVertexSelectionTags();
//	}
	var clickPt=pickOrMakePointEdgeSplit(viewCursor());
	console.log("multitool click down: clicked pt tag="+ (clickPt?(clickPt.tag?1:0):"no click pt"));
	clickPt.tag^=true;
	// maybe continue poly draw..
	if (clickPt.tag){g_drawingPoly.push(clickPt);} else {g_drawingPoly=[];}
    if (g_multiToolLastPoint && clickPt) {
		// todo: not if edge exists.
		AddEdgeMaybeSplitPoly(g_multiToolLastPoint, clickPt);
		// todo - this tool should optionally fill a polygon if you click one out
		if (g_drawingPoly[0] && clickPt==g_drawingPoly[0]){
			console.log("fill poly?");
		}
    }
	if (g_multiToolLastPoint){
		g_multiToolLastPoint.tag=false;
	}
	if (clickPt.tag){
		g_multiToolLastPoint=clickPt;
	} else {
		g_multiToolLastPoint=null;
	}
	console.log("draw polyline- vertices="+g_drawingPoly.length);


  },
  mousedrag: function(e){
	var vc=viewCursor();
	if (g_multiToolLastPoint){
		vaddto(g_multiToolLastPoint,
			screenDeltaToWorldAt(vc,g_mouseScreenDelta));
	}
	g_drawingPoly=[]; // cancels poly draw.
  },
  mousedragend: function(e){
	console.log("multitool drag end");
	if (g_multiToolLastPoint){
		g_multiToolLastPoint.tag=false;
		g_multiToolLastPoint=null;//we dont draw from point adjustments
	}
  },
  // cancel,bound to escape key
	mouserightclick:function(e){
	    g_multiToolLastPoint=null;
	},
  cancel: function(){
    g_multiToolLastPoint=null;
	g_drawingPoly=[];
  },
  // click - like 'adjust tool', 
  // except it might draw edges if points are tagged.
  mouseclickup: function(e){
	console.log("multiTool- click up");
  },

}


function adjustToolMouseDrag(e){
	var vc=viewCursor();
    if (g_adjustPoint){
		SetCursor("move");

      //can only adjust current poly
	  // TODO: Clean this up by going through vertex tag/translate

      // edge split operation?
	  var pointToMove;
      if (g_adjustPoint.edge){
        console.log("move tool-split edge.");
		ClearVertexSelectionTags();
        var pl=g_adjustPoint.poly;
        var edgeStart=g_adjustPoint.edge[0];
        var edgeEnd=g_adjustPoint.edge[1];
        newPt=g_adjustPoint.pickedPoint;//vaverage(edgeStart,edgeEnd);

        //newPt=g_mousepos;
        // step through all the polys again, because the vertices/edge may be shared.

		foreachPolygon( function(pl){ splitEdgeOfPoly(pl, edgeStart,edgeEnd, newPt) } );
		pointToMove = newPt;
		g_adjustPoint.edge=null;
		g_adjustPoint.selPoint=newPt;
	  }

      pl=g_adjustPoint.poly;

      if (g_adjustPoint.selPoint || g_hackMoveTaggedVertices){
	    if (g_hackMoveTaggedVertices){
			selectedVertices=GetSelectedVertices();
			selectedVertices.forEach(function(val,keyvt,map){
				vaddto(keyvt,screenDeltaToWorldAt(vc,g_mouseScreenDelta));
			});
		} else {
			// todo fix this to ALL be tag based.
        //move a vertex..
	   		pointToMove = g_adjustPoint.selPoint;
			vaddto(pointToMove, screenDeltaToWorldAt(vc,g_mouseScreenDelta));
			pointToMove.tag=true;
//			pointToMove.x+=g_mouseDelta.x;
//			pointToMove.y+=g_mouseDelta.y;
		}
      }
	  else if (!g_adjustPoint.edge && !g_adjustPoint.selPoint && g_adjustPoint.pickedPoint) {
        // move the whole poly..
        for (pti=0; pti<pl.points.length;pti++){
			vaddto(pl.points[pti],screenDeltaToWorldAt(vc,g_mouseScreenDelta));//needs selection centroid for scaling!
        }
      }
    } else{
			SetCursor("default");
	}
};

g_adjustTool={
  name:"adjust vertices/edgesplit",
    drawfeedback:drawFeedbackPickPolyPoint,
  activate:function(e){
  },
  mousepassivemove: function(e){
  },
  mousedrag: adjustToolMouseDrag,
  mousedown: function(e){
    var pick=pickPolyFeatureAt(viewCursor(),100000.0);
    if (pick.poly){
      g_currPoly=pick.poly;
      g_adjustPoint=pick;
      if (pick.selPoint){
        console.log("move point..");
      }
    }
 	var pt=pickPointAt(viewCursor());
	if (!pt) {pt=g_adjustPoint.selPoint}
	if (pt && pt.tag){
		g_hackMoveTaggedVertices=true;
	} else {
		if (!isMultiSelect()){
			ClearVertexSelectionTags();
		}
		if (pt) {
			pt.tag=true;
		}

	}
  },
  mouseclickup: function(e){
	if (!isMultiSelect()){
		ClearVertexSelectionTags();
	}

 	var pt=pickPointAt(viewCursor());
	if (!pt){
		g_hackMoveTaggedVertices=false;
		if (g_adjustPoint){
			if (g_adjustPoint.selPoint){
				pt=g_adjustPoint.selPoint;
			}
		}
	}

	if (pt){
        console.log("tag a point..\n");
		if (!pt.tag){
	        console.log("tag new point\n");
		}
		//default mode, multi-select with unpredictable move effects
		// requires more effort (shift) or the dedicated tool.
		console.log("tag a point:"+JSON.stringify(pt));
		pt.tag=pt.tag?false:true;
	}

	console.log("adjust- click up");
    g_adjustPoint=null;
  },

  mousedragend: function(e){
	g_hackMoveTaggedVertices=false;
	console.log("adjust- drag up");
    g_adjustPoint=null;
  },
  // cancel,bound to escape key
  cancel: function(){
	g_hackMoveTaggedVertices=false;
    g_adjustPoint=null;
  }
};

g_tool=g_hexTool;
g_savedTool=null;
function PushTool(t){
	console.log("push tool "+t.name+" "+"saved:"+g_tool.name);
	g_savedTool=g_tool;
	SetTool(t);
}
function PopTool(){
	PopToolOr(null);
}
function PopToolOr(t){
	if (g_savedTool){
		SetTool(g_savedTool);
		g_savedTool=null;
	} else {
		SetTool(t);
	}
}
function SetTool(tool){
  if (g_tool){
    if (g_tool.deactivate){
      g_tool.deactivate();
    }
  }
  g_tool=tool;
  if (tool.activate){
    tool.activate();
  }
}


// JSON dump. TODO - connect to a server etc etc

function download(filename, text) {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  element.setAttribute('download', filename);

  element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}

function GetAsJSON(){
  return JSON.stringify(
   { imageurl:      g_img.src,//document.getElementById("imageurl").value,
     scaled_width:  g_imageWorldSize.x,
     scaled_height: g_imageWorldSize.y,
     polygons:      g_polys
   });
}
var g_downloadIndex=0;

// load the scene from a text file
function loadFromText(txt){
   var inputJSON=JSON.parse(txt);
   if (!inputJSON){
     alert("must load JSON format");
     return;
   }
   if (!inputJSON.imageurl && inputJSON.polygons){
     alert("incorret format, needs imageurl,polygons");
     return;
   }

   alert("Loading annotations for:"+inputJSON.imageurl);
//   LoadImage(inputJSON.imageurl); // doesnt work.. 
   // todo- how to safely set UI etc
   g_img.src=inputJSON.imageurl;
//   document.getElementById("imageurl").value;
   console.log("setting new polys,num= "+inputJSON.polygons.length);
   g_polys=inputJSON.polygons;
}

function Save(){
   filename=prompt("download as","annotations"+g_downloadIndex+".json"); g_downloadIndex+=1;
//   alert(GetAsJSON());
   download(filename,GetAsJSON());
};

// drag drop the annotation file in for load.
editor.ondragover=function(ev){
//  console.log("dragover");
  ev.preventDefault();
}

function GetDroppedUrlMaybe(dt){
  var url=dt.getData('URL');
  if (!url){url=dt.getData('url')}

  if (!url) {
    url = dt.getData('text/plain');
  }
  if (!url) { url=dt.getData('text');}
  if (!url) { url=dt.getData('Text');}
  if (!url) { url=dt.getData('text/plain');}
  if (!url) { url=dt.getData('text/html');}
  if (!url) {
        url = dt.getData('text/uri-list');
  }
//  if (dropdata){var dropurl = dropdata.attr('src');
//    if (!dropurl) 
//      dropurl = dropdata.find("img").attr('src');
//  }
  return url;
}
editor.ondrop=function(ev){
  console.log("got a drop");
  ev.preventDefault();
  var dt=ev.dataTransfer;
  
  var url=GetDroppedUrlMaybe(dt);
  // dropped a URL - treat it as background image
  if (url) {
    alert("dropped url="+dropurl);
    // process URL drop
    console.log("got URL drop?:"+url); 
    LoadImage(url);
    g_polys=[];

  }else {
  //dropped file: treat it as annotations data.
  // todo - import of LabelMe format,etc..
    console.log("processing file drop:");    // process File data drop
    var files = ev.target.files || ev.dataTransfer.files;

    for (var i=0,file; file=files[i];i++){
      console.log("got file drop:"+file+" l="+file.length); 
      reader = new FileReader();
      reader.onload = function(event) {
        console.log("file loaded:"+event.target);
        data = event.target.result;
        console.log("file loaded bytes="+data.length);
        loadFromText(data);        
      };
      reader.readAsText(file);
    }
  }
}

function Load(){
   var txt=prompt("enter JSON annotations");
   if (!txt){return;}
   
   // grab the stuff.
   loadFromText(txt);
};

function readMousePos(e) {
  var edrect = editor.getBoundingClientRect();

  var opos=g_mousePos;
  console.assert(e.clientX && e.clientY);
  g_mousePos=vfromxy(e.clientX-edrect.left,e.clientY-edrect.top);
  g_mouseScreenDelta=vsub(g_mousePos, opos);
//  g_mouseDelta.x=g_mousepos.x-opos.x;
//  g_mouseDelta.y=g_mousepos.y-opos.y;
}
var g_maxTouchFingers=0;
var g_numFingers=0;
function readTouchPos(e){
	var edrect = editor.getBoundingClientRect();
	var opos=g_mousePos;
	function readTouch(i){return vfromxy(e.touches[i].clientX-edrect.left,e.touches[i].clientY-edrect.top)};
	g_numFingers=0;
	if (e.touches[0]) {
		g_mousePos=readTouch(0);	
		g_mouseScreenDelta=opos?vsub(g_mousePos, opos):vzero();
		g_numFingers+=1;
	}

	if (e.touches[1]){
		g_numFingers+=1;
		g_maxTouchFingers=2;
		if (g_secondTouchPos){
			var opos2=g_secondTouchPos;
			g_secondTouchPos=readTouch(1);
			g_secondTouchDelta=vsub(g_secondTouchPos,opos2);
		}else{
			g_secondTouchPos=readTouch(1);
			g_secondTouchDelta=vzero();
		}
	} else{
		g_secondTouchPos=null;
	}
	
}

var g_multiTouchZoomFactor;
editor.addEventListener('touchstart',function(e){
	// we know it's an ipad.. need bigger tolerance
	g_multiTouchZoomFactor=g_zoom;
	g_snapRadius=20;
	g_maxTouchFingers=1;
	readTouchPos(e);
	g_leftmousebutton=true;	// treat it as LBM?
							// should we not wait for move,mouseup etc.
							// and really clear out 'click' behaviour
	e.preventDefault();
	editorMouseDownSub(e);
});
editor.addEventListener('touchend',function(e){
	readTouchPos(e);
	g_leftmousebutton=false;
	e.preventDefault();
	if (g_maxTouchFingers>1)	// 2finger drag is only navigation.
		return;
	editorMouseUpSub(e);
	}
);
g_secondTouchPos;
editor.addEventListener('touchmove',function(e){
	readTouchPos(e);
	e.preventDefault();
	if (e.touches[1]){
		g_leftmousebutton=false; // cancel any previous 'drag' behaviour
		multiTouchNav(e);
		repaint();
	}
	else{
		editorMouseMoveSub(e);
	}
});

function isMultiTouch(){ return g_maxTouchFingers>1;}

function multiTouchNav(e){
	var worldDelta=screenDeltaToWorld(viewCursor(),g_mouseScreenDelta);

	vsubto(g_viewCentre,worldDelta);
	printAt(100,100,"4"+JSON.stringify([g_mouseScreenDelta,g_secondTouchDelta]));
	if (g_mouseScreenDelta && g_secondTouchDelta){
		var fingerOfs=vsub(g_secondTouchPos,g_mousePos);
	printAt(100,120,"1");
		var fingerDeltaDelta=vsub(g_secondTouchDelta,g_mouseScreenDelta);
		var newFingerOfs=vsub(vadd(fingerOfs,g_secondTouchDelta),g_mouseScreenDelta);
	printAt(100,130,"1");
		var factor=vlength(newFingerOfs)/vlength(fingerOfs);
		g_multiTouchZoomFactor*=factor;
		var mtz=g_multiTouchZoomFactor;
		// a little denoising, but we know this can be done better 
		if (mtz>g_zoom*1.025 || mtz<g_zoom/1.025){
			ZoomByAt(viewCursor(),(g_multiTouchZoomFactor/g_zoom));
			g_multiTouchZoomFactor=g_zoom;
		}
	}
}

function debugDrawMultiTouch(ctx){
			ctx.globalAlpha=0.75;
			ctx.strokeStyle="#ffffff";
			vdrawcircle(ctx,g_secondTouchPos,20);
			vdrawcircle(ctx,g_mousePos,20);

			printAtInCtx(ctx,200,100,"1"+JSON.stringify(
				[newFingerOfs,fingerOfs]
			));
		}

window.addEventListener('resize',function(e){
	Resize();
	repaint();
},true);

editor.addEventListener('mousemove',function(e){readMousePos(e);editorMouseMoveSub(e)});
function editorMouseMoveSub(e){
	

	if (g_multiSelectDrag){
		console.log("g_multiSelectDrag");
		multiSelectMouseMove(e);
	}else if (isMultiSelect()){
		g_drawfeedback=dragFeedbackMultiSelect;
	}else {
		if (g_leftmousebutton){
			if (g_tool.mousedrag) {
				g_tool.mousedrag(e);
			}
		} else {
			if (g_tool.mousepassivemove) {
				g_tool.mousepassivemove(e);
			}
		}
	}
	repaint();
}

editor.addEventListener("wheel", function(e){
	//console.log("mouse wheel event"+JSON.stringify(e)+e.deltaY);
	var factor=1.0;
	if (e.deltaY>0){ factor=1.08;
	} else if (e.deltaY<0){
		factor=1.0/1.08;
	}
	ZoomByAt(viewCursor(),factor);
	repaint();
});


function removeFromArray(as,a){
	for (var i=0; i<as.length; i++){
		if (as[i]===a){
			for (var j=i;j+1<as.length;j++){
				as[j]=as[j+1];
			}
			as.pop();
			return;
		}
	}
}

function isParentOf(a,b){
	if (a.polygons){
		for (var i=0; i<a.polygons.length; i++){
			if (a.polygons[i]==b){
				return true;
			}
			if (isParentOf(a.polygons[i],b)){
				return true;
			}
		}
	} else {
		return false;
	}
}

function RenamePoly(){
  if (g_polys.length<=0) return;
  poly=g_currPoly;
  newname=prompt("enter new label",poly.name);
  poly.name=newname;
  console.log(g_defaultColors[newname]);
  if (g_defaultColors[newname]){
    poly.color=g_defaultColors[newname];
  }
}
function MyConfirm(txt){
	if (!g_promptSevereTools)
		return true;
	return confirm(txt);
}
function getListContainingPolySub(poly,pls){
	for (var i=0; i<pls.length; i++){
		if (pls[i]==poly){
			return pls;
		}
		if (pls[i].polygons){
			var ret;
			if (ret=getListContainingPolySub(poly,pls[i].polygons)){
				return ret;
			}
		}
	}
	return null;
}
function getListContainingPoly(poly){
	return getListContainingPolySub(poly,g_polys);
}
function DeleteCurrentPoly(){
	console.log("delete a polygon\n");
	if (!g_currPoly){return;}
	var pls=getListContainingPoly(g_currPoly);
	if (!pls){
		console.log("could not find list for "+g_currPoly.name);
	}
    if (MyConfirm("delete poly:"+g_currPoly.name+"in list of "+(pls?pls.length:1))){
		var i=getIndexOfPoly(pls,g_currPoly);
		pls.splice(i,1);
		g_currPoly=null;//i<pls.length?pls[i]:null;
	}
}

function numSelectedVertices(){
	var accum=0;
	foreachVertex(function(v){ if (v.tag){accum+=1;}});
	return accum;	
}
function MergeVertices(){
	console.log("merge vertices");
	var accum=vzero();
	var total=0;
	accum.tag=true;
	var selvt=GetSelectedVertices();
	selvt.forEach(function(v,vt,m){ total+=1; vaddto(accum,vt);});
//	foreachVertex(function(v){ if (v.tag){vaddto(accum,v);total+=1;}});
	var newpolys=[];
	if (total>0){
		console.log("vertices to merge:"+total);
		var mergedPt=vscale(accum,1.0/total);
		console.log("merge at:"+JSON.stringify(mergedPt));
		if (!MyConfirm("merge "+total+" vertices \nat"+JSON.stringify(mergedPt))){
			return;
		}

		for (var i=0; i<g_polys.length; i++){
			pl=g_polys[i];
			var newpts=[];
			var lastadded=null;
			for (var j=0; j<pl.points.length; j++){
				vt=pl.points[j];
				if (!vt.tag){newpts.push(vt);lastadded=vt;}
				else{
					if (lastadded!=mergedPt){
						lastadded=mergedPt;
						newpts.push(mergedPt);
					}
				}
			}
			if (newpts.length>2){
				if (newpts[0]==newpts[1]){ newpts.pop();}
			}
			if (newpts.length>1){
				newpolys.push({points:newpts,color:pl.color, name:pl.name});
			}
		}
		g_polys=newpolys;
	}
}
function cloneVertex(v){
	return {x:v.x, y:v.y, z:v.z, tag:v.tag, name:v.name, color:v.color}
}
function SeperateVertices(){
	console.log("seperate vertices");
	var vertexPolyMap=new Map(); // every combination of poly,vertex
	for (var i=0;i<g_polys.length;i++){
		pl=g_polys[i];
		for (var j=0; j<pl.points.length;j++){
			vt=pl.points[j];
			if (vt.tag){
				// create or get a map for the vertex,
				if (!vertexPolyMap.has(vt)) {
					vertexPolyMap.set(vt,new Map());
				}
				var polysPerVertex=vertexPolyMap.get(vt);
				// put the poly's respective version on the vertex
				polysPerVertex.set(pl,(!vt.tag)?vt: cloneVertex(vt));
			// mark that the vertex has this poly
			}
		}
	}
	vertexPolyMap.forEach(function(val,keyvt,map){
		console.log("vertex map - %d polys{",val.length);
		val.forEach(function(val,keypl,map){
			console.log("\tpoly %s",keypl.name);
		});
		console.log("}");
	});
	// pass 2 change whats needed
	for (var i=0;i<g_polys.length;i++){
		pl=g_polys[i];
		for (var j=0; j<pl.points.length;j++){
			vt=pl.points[j];
			if (vt.tag){
				newvt=vertexPolyMap.get(vt).get(pl);
				pl.points[j]=newvt;
			}
		}
	}
}

function DeleteVerticesSub(polys){
	console.log("delete vertices\n");
	var newpls=[];

	for (var i=0;i<polys.length; i++){
		var pl=polys[i];
        if (pl.polygons){
           pl.polygons=DeleteVerticesSub(pl.polygons);
        }
		var newpl={points:[],color:pl.color,name:pl.name, polygons:pl.polygons};
		for (var j=0; j<pl.points.length; j++){
			vt=pl.points[j];
			if (!vt.tag){
				newpl.points.push(vt);
			}
		}
		if (newpl.points.length>=0){
			newpls.push(newpl);
		}
        
	}
	return newpls;
}
function DeleteVertices(){
  var num=0;
  foreachVertex(function (v){if (v.tag){num+=1;}});
  if (!MyConfirm("delete "+num+" vertices?")){return;}

  g_polys=DeleteVerticesSub(g_polys);
  repaint();
}
// context sensitive delete.
function Delete(){
	console.log("context sensitive delete\n");
	var n=numSelectedVertices()
	if (n>0){
		if (MyConfirm("delete "+n+" vertices?")){
			DeleteVertices();
		}
	} else {
		DeleteCurrentPoly();
	}
}

function foreachPolygonEdgeSub(pls,f){
	for (var i=0;i<g_polys.length; i++){
		pl=g_polys[i];
		for (var j=0; j<pl.points.length; j++){
			pt0=pl.points[j]; pt1=pl.points[(j+1)%pl.points.length];
			f(pl,pt0,pt1);
		}
		if (pl.polygons){foreachPolygonEdgeSub(pl.polygons,f);}
	}
}
function foreachPolygonEdge(f){
	foreachPolygonEdgeSub(g_polys,f);
}

function foreachPolygonSub(pls,f){
	for (var i=0; i<pls.length; i++){
		var pl=pls[i];
		f(pl);
		if (pl.polygons){foreachPolygonSub(pl.polygons,f);}
	}
}
function foreachPolygon(f){
	foreachPolygonSub(g_polys,f);
}

function edgeMapGetOrInsert(edgeMap, vs,ve, f){
	if (edgeMap.has([vs,ve])) {return edgeMap.get([vs,ve]);}
	if (edgeMap.has([ve,vs])) {return edgeMap.get([ve,vs]);}
	edgeMap.set([vs,ve], f());
	return edgeMap.get([vs,ve]);
}

function getEdgeMapFiltered(predicate_func) {
	edgeMap=new Map();
	foreachPolygonEdge(function(pl,vs,ve) {
		if (predicate_func(pl,vs,ve)){
			em=edgeMapGetOrInsert(edgeMap,vs,ve, function(){return new Set();});
			if (em){
				em.set(pl,true);
			}
			edgeMap.set([vs,ve], true); // every polygon of that edge aswell?
		}
	});
	return edgeMap;
}
function getSelectedEdgesByVertices(){
	return getEdgeMapFiltered(function(pl,vs,ve){return vs.tag && ve.tag;});
}
function edgeMapGet(edgeMap,vs,ve){
	if (edgeMap.has([vs,ve])) {return edgeMap.get([vs,ve]);}
	if (edgeMap.has([ve,vs])) {return edgeMap.get([ve,vs]);}
	return null;
	
}

function edgeMapGetOrCreate(edgemap, vs,ve){
	var verticesPerVertex = edgemap.get(vs);
	if (!verticesPerVertex){
		verticesPerVertex=new Map();
		edgemap.set(vs,verticesPerVertex);
	}
	var edge=verticesPerVertex.get(ve);
	if (edge){return edge;}
	// first check if the other vertex has this link..
	othervm=edgemap.get(ve);
	if (!othervm){
		othervm=new Map();
		edgemap.set(ve,othervm);
	}
	otherEdge= othervm.get(vs);
	if (otherEdge){
		// if so store and return
		verticesPerVertex.set(ve,otherEdge);
		return otherEdge;
	}

	// otherwise, make a new edge..
	edge=[vs,ve];
	verticesPerVertex.set(ve,edge);
	othervm.set(vs,edge);
	return edge;
}
function makeEdgeMap(){
	// 
	ptedges=new Map();
	for (var i=0; i<g_polys.length; i++){
		pl=g_polys[i];
		for(var j=0; j<pl.points.length;j++){
			var vs=pl.points[j];
			var ve=pl.points[(j+1)%pl.points.length];
			edgeMapLink(ptedges,vs,ve);
			edgeMapLink(ptedges,ve,vs);
		}
	}
}

function CopyToClipboard(){
	console.log("TODO-clipboard copy, hack ctrl-v is just duplicate");	
}

function CutToClipboard(){
	console.log("TODO-clipboard copy, hack ctrl-v is just duplicate");
	CopyToClipboard();
	DeleteSelectedPolygons();
}
function GetSelectedVertices(){
	var selVertexMap=new Map();
	foreachVertexOfPolygon(function(vt,pl){ if (vt.tag){selVertexMap.set(vt,true);}})
	return selVertexMap;
}
function GetVertexMapCentroid(selVertexMap){
	var acc=vzero();
	var num=0;
	selVertexMap.forEach(function(v,vt,m){
		vaddto(acc,vt);num+=1;
	});
	if (num>0){
		return vscale(acc,1.0/num);
	} else {
		return vzero();
	}
}
function GetVertexMapExtents(selVertexMap){
	var lo=vsplat(1000000.0);
	var hi=vsplat(-1000000.0);
	selVertexMap.forEach(function(v,vt,map){
		lo=vmin(lo,vt);
		hi=vmin(hi,vt);
	});
	return {min:lo,max:hi};
};

function GetSelectedVerticesCentroid(){//GetSelectedVerticesCentroid() GetCentroid()
	return GetVertexMapCentroid(GetSelectedVertices());
}

function PasteFromClipboard(){
	console.log("paste/duplicate - no clipboard yet so we paste");
	// todo: poly mode, vertex mode, edge mode
	// or poly/vertex/edge mixed selection
	vc=viewCursor();
	g_currPoly=null;
	selPolyMap=new Map();
	selVertexMap=new Map();
	foreachVertexOfPolygon(function(vt,pl){
		if (vt.tag){selPolyMap.set(pl,true);}
	});
	foreachVertexOfPolygon(function(vt,pl){
		if (selPolyMap.get(pl)){
			selVertexMap.set(vt,vt);
		}
	});
	// duplicate at the cursor?
	var accumvt=vzero();
	var numpts=0;
	selVertexMap.forEach(function(val,keyvt,map){
		newvt=cloneVertex(keyvt)
		selVertexMap.set(keyvt, newvt);
		newvt.tag=true;
		keyvt.tag=false;
		vaddto(accumvt,newvt);
		numpts++;
	});
	var selCentre=vscale(accumvt,1.0/numpts);
	var screenDelta=vsub(g_mousepos,worldToScreen(vc,selCentre));
	var worldDelta=screenDeltaToWorldAt(vc,screenDelta);
	selVertexMap.forEach(function(newvt,keyvt,map){
		vaddto(newvt,worldDelta);
	});
	selPolyMap.forEach(function(val,keypl,map){
		newpl={points:[],name:keypl.name, color:keypl.color};
		for (var i=0; i<keypl.points.length; i++){
			duplicateVt=selVertexMap.get(keypl.points[i]);
			
			newpl.points.push(duplicateVt);
		}
		g_polys.push(newpl);
		g_currPoly=newpl;	// this is a  hack we will eliminate
	});
}

function NumTaggedEdges(pl){
	var num=0;
	for (var i=0; i<pl.points.length; i++){
		var vs=pl.points[i]; var ve=pl.points[(i+1)%pl.points.length];
		if (vs.tag && ve.tag){	// subdiv style edge.. no
			num+=1;
		}
	}
	return num;
}

function SplitPolyByEdge(pl, vs,ve){
	polys=getListContainingPoly(pl);
	var pts0=[],pts1=[];
	var side=0;
	for (var i=0; i<pl.points.length; i++){
		var pt=pl.points[i];
		if (pt==vs||pt==ve){
			pts0.push(pt); pts1.push(pt);
			side^=1;
		} else{
			if (!side) pts0.push(pt); else pts1.push(pt);
		}
	}
	if (pts0.length>2 && pts1.length>2){
		// if both list have more than 2 - this wasn't just an existing edge
		var newpl={points:pts1, name:pl.name, color:pl.color};
		pl.points=pts0;
		polys.push(newpl);
	}
}

function SplitByTaggedVertices(newpls,pl){
	console.log("split by tagged vertices..\n");
	var numTags=0;
	var polys0=[],polys1=[];
	var side=0;
	for (var i=0; i<pl.points.length; i++){
		var pt=pl.points[i];
		if (pt.tag){
			polys0.push(pt); polys1.push(pt);
			side^=1;
		} else{
			if (!side) polys0.push(pt); else polys1.push(pt);
		}
	}
	console.log("split poly:"+pl.length+"->"+polys0.length+","+polys1.length);
	var pl2={};// make a new poly, and insert into the list
	pl2.points=polys1;
	pl.points=polys0;
	pl2.name=pl.name; pl2.color=pl.color;
	newpls.push(pl);
	newpls.push(pl2);
	return true;
}

function SubdivideByVertices(){
	vtc=GetSelectedVertices();
	g_polys=SubdivideByVerticesSub(g_polys);
	vtc.forEach(function(val,pt,map){
		pt.tag=false;
	});
}
function SubdivideByVerticesSub(polys){
	// every edge- potentially split in the middle.
	// every poly with 2 vertices - split between them
	// every poly with all vertices set: add a midpoint while you're at it..2254
/*	console.log("subdivide by vertices");
	var edgemap=getSelectedEdgesByVertices();
	var edgeMidPts=new Map();
	console.log("split edges..:-");
	// create the split points per edge,
	edgemap.forEach(function(val,edge,map){
		midpt=averagePoint(edge[0],edge[1]);
		console.log("edge:"+JSON.stringify(edge)+" made midpoint:"+JSON.stringify(midpt));
		edgeMidPts.set(edge,midpt);
	});
*/
	// vertex -> all the edges off it.
	edgemap=new Map();
	//can't just use [vs,ve] as keys adhoc; must be unique [vs,ve] object
	console.log("create midpoints & build edgemap:-");
	edgeMidPts=new Map();
	for (var i=0; i<polys.length; i++){
		pl=polys[i];
		if (pl.polygons){
			pl.polygons=SubdivideByVerticesSub(pl.polygons);
		}
		for(j=0; j<pl.points.length;j++){
			var vs=pl.points[j];
			var ve=pl.points[(j+1)%pl.points.length];
			if (!(vs.tag==true && ve.tag==true)){continue;}
			edge=edgeMapGetOrCreate(edgemap,vs,ve);
			if (edgeMidPts.has(edge)) continue;		
			var midpt=vaverage(vs,ve);
			midpt.tag=true;
			edgeMidPts.set(edge, midpt);
		}
	}
	var newpl,midpt;
	var newPolyList=[];
	console.log("subdiv- poly list");
	for (pli=0; pli<polys.length;console.log("increment pli"+pli), pli++){
		console.log("subdiv- poly "+pli+"of"+polys.length);
		var pl=polys[pli];
		var numTagged=0;
		for (var j=0; j<pl.points.length; j++){
			if (pl.points[j].tag) {
				numTagged+=1;
			}
		}
		if (!numTagged){
			newPolyList.push(pl);
		} else if (numTagged==pl.points.length ){
			console.log("subdiv- whole poly "+i);
			// subdivide edges and whole polygon:-
			polymidv=polyCentre(pl.points);
			for (vti=0; vti<pl.points.length; vti++){
				// splitting in this order retains obvious quad subdiv
				console.log("subdiv- whole poly"+i+" createSub"+vti);
				var v0=pl.points[vti];
				var v1=pl.points[(vti+1)%pl.points.length];
				var v2=pl.points[(vti+2)%pl.points.length];
				var midv01=edgeMidPts.get(edgeMapGetOrCreate(edgemap,v0,v1));
				var midv12=edgeMidPts.get(edgeMapGetOrCreate(edgemap,v1,v2));
				var subpl={points:[midv01,v1,midv12,polymidv],name:pl.name,color:pl.color};
				newPolyList.push(subpl);
			}
			console.log("done subdiv whole poly ");
		}else if (numTagged==2 && NumTaggedEdges(pl)==0){
	 		SplitByTaggedVertices(newPolyList,pl);
		}else {	
			// just subdivide edges
			console.log("subdiv- poly edges");
			newpl={points:[], name:pl.name,color:pl.color};
			for (var j=0; j<pl.points.length; j++){

				var vs=pl.points[j];
				var ve=pl.points[(j+1)%pl.points.length];
				newpl.points.push(vs);
				console.log("look for split of"+JSON.stringify([vs,ve]));
	/*			if (edgeMidPts.has([vs,ve]) || edgeMidPts.has([ve,vs])){
					console.log("midpoint there..\n");
				};
				if (edgeMidPts.has([vs,ve])){midpt=edgeMidPts.get([vs,ve]);}
				else if (edgeMidPts.has([ve,vs])){midpt=edgeMidPts.get([ve,vs]);}
				*/
				midpt=null;
				edge=edgeMapGetOrCreate(edgemap,vs,ve);
				if (edgeMidPts.has(edge)){
					console.log("found midpoint: for "+j);
					newpl.points.push(edgeMidPts.get(edge));
				}
			}
			newPolyList.push(newpl);
			console.log("done edge subdiv poly");
		}
	}
	console.log("subdiv- done");
	return newPolyList;
}
function ViewToggle(){
	g_viewMode+=1;
	if (g_viewMode==3){
		g_viewMode=0;
	}
}
function isMultiSelect(){
	return (g_ctrl && g_ctrlIsMultiSelect);
}
editor.addEventListener('mousedown',function(e){readMousePos(e);editorMouseDownSub(e)});

function editorMouseDownSub(e){
	
		g_leftmousebutton=true;
		if (e.button==2){
			e.preventDefault();
		} else {
			// lbutton
			g_dragstartpos=cloneVertex(g_mousePos);

		// todo - inherit shift-overide in the tool func?
			if (isMultiSelect()){
				multiSelectMouseDown(e);
			} else {
				console.log("g_tool mousedown:"+g_tool.name+(g_tool.mousedown?" yes":"null"));
				if (g_tool.mousedown){
					g_tool.mousedown(e);
				}
			}
		}
		repaint();
	};
g_dragLineDragging=false; // temp hack, fugly.
editor.addEventListener('mouseup',
	function(e){
		g_leftmousebutton=false;
		readMousePos(e);
		editorMouseUpSub(e)
	}
);
function compose(f1,f2){return function(){f1();f2();}};
function editorMouseUpSub(e){
	
//	if (g_multiSelectDrag){
//		multiSelectMouseDragUp(e);
//	}else
//	{
	if (e.button==2){
		if (g_tool.mouserightclick){
			g_tool.mouserightclick(e);
			e.preventDefault();
		}
	} else{
		// tools can distinguish drag-release from click-release
		if (distSquared2d(g_dragstartpos,g_mousePos)>0){
			if (isMultiSelect() || g_multiSelectDrag){
				multiSelectMouseDragUp(e);
			} else{
				if (g_tool.mousedragend){
					g_tool.mousedragend(e);
				}
			}
		} else {
			if (isMultiSelect()){
				multiSelectMouseClickUp(e);
			}else{		

				if (g_tool.mouseclickup){g_tool.mouseclickup(e);};
			}
		}
	}
	g_multiSelectDrag=false;
	g_dragstartpos=null;
	repaint();

}

window.addEventListener('keyup', function(e){
  kc=e.keyCode;
  console.log("keyup:"+kc);
  if (kc==16){g_shift=false;} 
  if (kc==17){g_ctrl=false;}
  if (kc==18){g_alt=false;}
  if (kc==32 && g_spacebarIsVirtualMouseButton){
    g_leftmousebutton=false;
    editorMouseUpSub(e);
  }
});
function isCommandModifier(e){
	return (g_ctrl || e.getModifierState("OS"));
}

function FrameAll(){
	if (g_img){
		console.log("framing image\n");
		frameImage();
	} else{
		console.log("TODO: frame current meshes\n");
	}
}

editor.addEventListener('contextmenu',
  function(e) {
	e.preventDefault();
    if (g_tool.contextmenu){
	  g_tool.contextMenu(e);
      e.preventDefault();
    }
//	if (g_tool.mouserightclick){
//		g_tool.mouserightclick(e);
 //     e.preventDefault();
//	}
	else {
	
	  //g_contextMenu=mainContextMenu(e);
      //e.preventDefault();
	}
  },
  false
);

function ZoomByAt(vc, factor){
	// todo: in 2d views, 'zoom at point'
	var ofs=vsub(vc.worldpos, g_viewCentre);
//	vaddto(g_viewCentre,ofs);
	g_zoom*=factor;

//	console.log("vc="+JSON.stringify(vc));
	if (viewIs2d(vc.view)){
		vmaddto(g_viewCentre,ofs,-1+factor);
	}
}
function Cancel(){
	if (g_tool){if (g_tool.cancel){g_tool.cancel();repaint()}};
	
}


g_nextUiGroup=0;
var g_firstButton=null;
function getTopButton(i){
  return document.getElementById("b"+i);
}
g_uiGroup_CurrentSubTool = new Map();
function CreateUIGroup(dat,mainName,tooltip,mainfunc,subls) {
  console.log("mk ui grp "+dat.name);
  var btn=document.getElementById("b"+g_nextUiGroup);
  btn.innerHTML=mainName;
  btn.title=tooltip;
  g_nextUiGroup+=1;

 // var f=function() {
//  }

  if (subls){
   for (var i=0; i<subls.length;i++){ 
    sub=subls[i];
    console.log("make sub button for "+sub.name);
	sub.composed_func= function(){
		console.log("sub"+i+" of "+mainName+","+dat.name);
		if (dat.sub){
			console.log("sub "+dat.sub[i].name);
			dat.sub[i].onpress();repaint();};
		}
   }
  }

  btn.onclick= function(){setSubButtons(dat,btn);}
  
  if (!g_firstButton && subls){g_firstButton=btn;}
}

function setSubButtons(dat,btn){//mainName,mainfunc,btn,subls){
	var mainName=dat.name;
	var mainfunc=dat.onpress;
	var subls=dat.sub;
    for (var i=0; i<g_nextUiGroup; i++) {
       getTopButton(i).style.background="#e0e0e0";
    }
    btn.style.background="#ffffff";
    console.log("ui:"+mainName);
    if (mainfunc){
      mainfunc();
    }
    var i;
    if (subls){
    for (i=0; i<subls.length; i++){
       var sub=subls[i];
       var sbtn=getTopButton(i+g_nextUiGroup);
       sbtn.className="subbutton";
       sbtn.innerHTML=sub.name;
		sbtn.class="button"
		subf=sub.onpress;
		sbtn.onclick=compose(subf,repaint); // sub.composed_func
    }
    for (i=subls.length;i<14-g_nextUiGroup; i++){
       var sbtn=document.getElementById("b"+(g_nextUiGroup+i));
       sbtn.onclick=null;
       sbtn.innerHTML="";
    }
    }else{
      // this is a plain tool, no subtools, so keep existing subtools visible.
    }
    repaint();
}

function uidone(){
  g_firstButton.onclick();
}

function DeselectAll(){
  foreachVertex(function(v){v.tag=false;});
  repaint();
}
function SelectAll(){
  foreachVertex(function(v){v.tag=true;});
  repaint();
}
function InvertSelection(){
	var vm=GetVertexMap();
	vm.forEach(function(val,vt,map){
		vt.tag^=true;
	});
}

function SelectVerticesConnectedByPolygons(){
  var plmap=new Map();
  foreachVertexOfPolygon(function(vt,pl){
    if (vt.tag) { plmap.set(pl,true);}
  });
  foreachVertexOfPolygon(function(vt,pl){
    if (plmap.has(pl)){vt.tag=true;}
  });
}

function GetVertexVertexMap(){
	var vmaps=new Map();	// map of every vertex-vertex 
	var insertVertexVertexMapSub=function(vs,ve){
		if (!vmaps.has(vs)){ vmaps.set(vs,new Map());}
		if (!vmaps.has(ve)){ vmaps.set(ve,new Map());}
		vmaps.get(vs).set(ve,true);
		vmaps.get(ve).set(vs,true);
	}

	foreachPolygonEdge(function(pl,vs,ve){
		insertVertexVertexMapSub(vs,ve);
		insertVertexVertexMapSub(ve,vs);
	});
	return vmaps;
}

function SelectVerticesConnectedByEdges(){
	var vmap=GetVertexVertexMap();
	var vtc=GetSelectedVertices();
	vtc.forEach(function(val,vs,map){
		vmap.get(vs).forEach(function(val,ve,map){
			ve.tag=true;
		});
	});
}
function ShrinkSelection(){
	var vmaps=GetVertexVertexMap();
	var unset=new Map();
	// get set of vertices not selected
	vmaps.forEach(function(vmap,vs,m){
		vmap.forEach(function(val,ve,map){
			if (vs.tag && ve.tag){return;}
			if (vs.tag) {unset.set(vs,true);}	
			if (ve.tag) {unset.set(ve,true);}	
		})
	});
	unset.forEach(function(v,vt,m){ vt.tag=false;})
}

function DeselectInteriorVertices(){
	var vmaps=GetVertexVertexMap();
	var set=new Map();
	// get set of vertices not selected
	vmaps.forEach(function(vmap,vs,m){
		vmap.forEach(function(val,ve,map){
			if (vs.tag && ve.tag){return;}
			if (vs.tag) {set.set(vs,true);}	
			if (ve.tag) {set.set(ve,true);}	
		})
	});
	DeselectAll();
	set.forEach(function(v,vt,m){ vt.tag=true;})
}

function mkset(tool){return function(){SetTool(tool);}};
function findButtonInfo(name){
	for (var i=0; i<g_uigroups.length;i++){
        if (!g_uigroups[i].sub) continue;
		for(var j=0;j<g_uigroups[i].sub.length;j++){
           if (g_uigroups[i].sub[j].name==name){
				return g_uigroups[i].sub[j];
           }
        }
    }
   return null;
}
g_uigroups=[
	{name:"file",
		info:"file management,misc",
		onpress:null,
		sub:[
			{name:"new image",onpress:NewImage},
			{name:"load",onpress:Load},
			{name:"save",onpress:Save},
			{name:"help",onpress:Help}
		]
	},
	{name:"adjust",info:"adjust polygons by moving vertices and splitting edges", onpress:mkset(g_adjustTool),sub:null},
	{name:"draw",info:"primitive drawing tools",onpress:mkset(g_polyTool),
		sub:[
			{name:"points",onpress:mkset(g_pointTool)},
			{name:"poly-line",onpress:mkset(g_multiTool)}, // default..
			{name:"rect",onpress:mkset(g_rectTool)},
			{name:"poly",onpress:mkset(g_polyTool)},
			{name:"lasso",onpress:mkset(g_lassoDrawTool)},
			{name:"cancel",onpress:Cancel}
		]
	},
	{	name:"vertex",
		info:"vertex selection and mesh manipulation tools",
		onpress:mkset(g_selectTool),
		sub:[
		  {name:"subdiv",onpress:SubdivideByVertices},
		  {name:"extrude",onpress:mkset(g_extrudeTool)},
		  {name:"seperate",onpress:SeperateVertices},
		  {name:"merge",onpress:MergeVertices},
		  {name:"deselect",onpress:DeselectAll},
		  {name:"delete",onpress:DeleteVertices}
		]
	},
	{
		name:"select",	// popup menu
		onpress:mkset(g_selectTool),
		sub:[
		  {name:"deselect",onpress:DeselectAll},
		  {name:"all",onpress:SelectAll},
		  {name:"invert",onpress:InvertSelection},
				{name:"connected by polys", onpress:SelectVerticesConnectedByPolygons},
				{name:"connected by edges", onpress:SelectVerticesConnectedByEdges},
				{name:"exterior", onpress:DeselectInteriorVertices},
				{name:"shrink", onpress:ShrinkSelection},
		]
	},
	{	name:"objects",
		info:"object list manipulation",
		onpress:null,
		sub:[ {name:"parent",onpress:mkset(g_parentTool)},
		    {name:"rename",onpress:RenamePoly},
		    {name:"next",onpress:function(){ToggleCurrentPoly(1)}},
		    {name:"prev",onpress:function(){ToggleCurrentPoly(-1)}},
		   {name:"info",onpress:Info},
		   {name:"delete",onpress:DeleteCurrentPoly}
		]
	},
	{	name:"view",
		info:"view options",
		onpress:null,
		sub:[
			{name:"show polys",onpress:function(){g_showAllPolys^=true}},
			{name:"show labels",onpress:function(){g_showLabelNames^=true}},
			{name:"frame all",onpress:FrameAll},
			{name:"single view",onpress:function(){g_viewMode=0}},
			{name:"3d view",onpress:function(){g_viewMode=2}}
		]
	}
];
console.log("g_uigroups="+g_uigroups.length);
for (var uigi=0; uigi<g_uigroups.length; uigi++){
//mainName,tooltip,mainfunc,sxubls
	var uig=g_uigroups[uigi];
	CreateUIGroup(uig,uig.name,uig.info,uig.onpress,uig.sub);
}

uidone();

window.addEventListener('keydown',  function(e){
  kc=e.keyCode;
  console.log("keypress:"+kc);
  // todo - programatic, show hotkeys.
  if (kc==32 && g_spacebarIsVirtualMouseButton){// issue a mouse click
	g_leftbutton=true; editorMouseDownSub(e);
  }
  if (kc==16){g_shift=true;} 
  if (kc==17){g_ctrl=true;}
  if (kc==18){g_alt=true;} 

//  if (kc==82){SetTool(g_hexTool)} 
//  else if (kc==66){SetTool(g_octTool)}
  else if (kc==65){if (g_ctrl){SelectAll()}else{SetTool(g_adjustTool)}}
  else if (kc==73){if (g_ctrl){InvertSelection()}else{/* insert?*/};}
  else if (kc==80){
    if (g_shift){ SetTool(g_parentTool);}
	else SetTool((g_alt)?g_quadstripTool:g_polyTool)
  }
  else if (kc==83){
	if (g_shift){
		SeperateVertices();
	} else
	SubdivideByVertices();
  }
  //d
  else if (kc==68){
	SetTool(g_multiTool);
//	ShowMaskedImages();
	}
  //h
  else if (kc==72){}
  //y
  else if (kc==89){}
  //x
  else if (kc==88){}
  else if (kc==87){SetTool(g_translateTool);}//w
  else if (kc==69){if (g_alt){PushTool(g_extrudeTool);}else{SetTool(g_rotateTool);}}//e
  else if (kc==82){SetTool(g_scaleTool);}//r

  //c
  else if (kc==67){if (isCommandModifier(e)) {CopyToClipboard()}}
  //v
  else if (kc==86){if (isCommandModifier(e)) {PasteFromClipboard()} else {ViewToggle();}}  
  //z
  else if (kc==90){}

  else if (kc==79){SetTool(g_pointTool)}
  else if (kc==84){SetTool(g_selectTool)}
  else if (kc==76){if (g_alt){SetTool(g_lassoDrawTool);}else{SetTool(g_lineTool);}}
  else if (kc==221){TogglePresetLabel(1);}
  else if (kc==219){TogglePresetLabel(-1);}
  else if (kc==27){Cancel();}
  else if (kc==13){RenamePoly();}
  else if (kc==188){ToggleCurrentPoly(-1);}
  else if (kc==77){
    MergeVertices();
  }
  else if (kc==190){ToggleCurrentPoly(+1);}
  else if (kc==8){Delete(+1);}
  else if (kc==187){ZoomByAt(viewCursor(),1.2);}
  else if (kc==189){ZoomByAt(viewCursor(),1.0/1.2);}

  if (kc==70){console.log("pressed f");FrameAll();}

  var step=40.0;
  var vp=getViewport(g_mousePos);
  var sdelta=vfromxyz(keyDelta(kc,37,39)*step,keyDelta(kc,38,40)*step,0);
  vaddto(g_viewCentre,screenDeltaToWorld({cursor:g_mousePos,view:vp},sdelta));
// todo .. parenting, renaming , delete vertex,...
  //readMousePos(e);
  repaint();
},false);

repaint();

var examples=[
  {imageurl:"https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Queen_Street_NOTL_1.jpg/1920px-Queen_Street_NOTL_1.jpg",
  labels:[]},
  {imageurl:"https://upload.wikimedia.org/wikipedia/commons/0/0a/Ickenham_-_water_pump%2C_pub%2C_and_houses_-_geograph.org.uk_-_20123.jpg",
  labels:[]},
{"imageurl":"https://upload.wikimedia.org/wikipedia/commons/5/5f/Vendeur_de_parapluie.jpg","scaled_width":1024,"scaled_height":768,"polygons":[{"points":[{"x":641.2,"y":133},{"x":631,"y":123},{"x":616,"y":118},{"x":602,"y":119},{"x":592,"y":124},{"x":589,"y":137},{"x":573,"y":144.375},{"x":577,"y":153},{"x":592,"y":154},{"x":595,"y":170},{"x":579,"y":243},{"x":563,"y":281},{"x":586,"y":308},{"x":590,"y":340},{"x":592,"y":388},{"x":576,"y":397},{"x":575.8,"y":407},{"x":593,"y":420},{"x":627,"y":417},{"x":633,"y":370},{"x":629,"y":333},{"x":636,"y":306.625},{"x":644,"y":276},{"x":648,"y":255},{"x":655,"y":200},{"x":638,"y":169},{"x":630,"y":151},{"x":640,"y":148}],"name":"person","color":"#1000f0"},{"points":[{"x":454.655,"y":155},{"x":461,"y":137},{"x":479,"y":129},{"x":506,"y":151},{"x":540.375,"y":153},{"x":583,"y":210.5},{"x":576,"y":293},{"x":571,"y":335},{"x":558.345,"y":388},{"x":533,"y":380},{"x":540,"y":363},{"x":506,"y":370},{"x":495.625,"y":364},{"x":523,"y":344},{"x":524,"y":308.5},{"x":493,"y":273},{"x":497,"y":237},{"x":485,"y":186},{"x":463,"y":175}],"name":"person","color":"#1000f0"},{"points":[{"x":659,"y":205.215},{"x":667,"y":190},{"x":679,"y":185},{"x":689,"y":187},{"x":685,"y":175},{"x":693,"y":164},{"x":720,"y":171},{"x":713,"y":197},{"x":743,"y":200},{"x":748.75,"y":193},{"x":814,"y":185.625},{"x":814,"y":207},{"x":797,"y":208},{"x":800,"y":197},{"x":776,"y":202},{"x":772,"y":209},{"x":777,"y":222},{"x":796,"y":228},{"x":812,"y":250},{"x":819,"y":284},{"x":810,"y":311.785},{"x":799,"y":323},{"x":777,"y":326},{"x":750,"y":307},{"x":740,"y":273},{"x":731,"y":269},{"x":723,"y":279},{"x":709,"y":276},{"x":702,"y":289},{"x":687.25,"y":292},{"x":670,"y":285},{"x":659,"y":269.375},{"x":652,"y":238}],"name":"bicycle","color":"#008000"},{"points":[{"x":357,"y":244.605},{"x":378,"y":238},{"x":387,"y":236},{"x":398.75,"y":236},{"x":459,"y":256},{"x":483,"y":278},{"x":504,"y":285.875},{"x":515,"y":332.395},{"x":479,"y":330},{"x":430,"y":306},{"x":404.25,"y":344},{"x":401,"y":341.125},{"x":423,"y":302},{"x":403,"y":289},{"x":375,"y":268}],"name":"umbrella","color":"#008000"},{"points":[{"x":894.06,"y":82},{"x":886,"y":71},{"x":873.5,"y":73},{"x":867,"y":85},{"x":872,"y":99},{"x":868,"y":117.75},{"x":861,"y":128},{"x":840,"y":124},{"x":850,"y":138},{"x":865,"y":148},{"x":869,"y":176},{"x":860,"y":190},{"x":869,"y":191},{"x":879.94,"y":189},{"x":891,"y":182},{"x":886,"y":172},{"x":883.5,"y":153},{"x":903,"y":160.25},{"x":914,"y":145},{"x":913,"y":122},{"x":906,"y":104},{"x":893,"y":94}],"name":"person","color":"#1000f0"},{"points":[{"x":868.62,"y":112},{"x":854,"y":86},{"x":851,"y":76},{"x":841,"y":68},{"x":829,"y":75},{"x":825.5,"y":83},{"x":829,"y":100},{"x":825,"y":109},{"x":815,"y":123},{"x":803,"y":130.125},{"x":812,"y":137},{"x":812,"y":151},{"x":810,"y":163},{"x":795,"y":171},{"x":798.38,"y":180},{"x":818,"y":173},{"x":819,"y":181},{"x":835.5,"y":177},{"x":842,"y":154.875},{"x":842,"y":137},{"x":864,"y":122}],"name":"person","color":"#1000f0"},{"points":[{"x":383.165,"y":83},{"x":364,"y":75},{"x":358.125,"y":60},{"x":333,"y":79.875},{"x":347,"y":93},{"x":340,"y":105},{"x":339,"y":121},{"x":329,"y":128},{"x":332,"y":141},{"x":342,"y":156},{"x":342.835,"y":196},{"x":358,"y":243},{"x":376,"y":239},{"x":377,"y":209},{"x":388.875,"y":238},{"x":410,"y":237.125},{"x":395,"y":181},{"x":407,"y":137},{"x":397,"y":93}],"name":"person","color":"#1000f0"},{"points":[{"x":167.17,"y":79},{"x":191.25,"y":78},{"x":188,"y":97},{"x":195,"y":108.625},{"x":198,"y":137},{"x":212,"y":168},{"x":206.83,"y":176},{"x":173.75,"y":169},{"x":164,"y":157},{"x":155,"y":160},{"x":149,"y":136.375},{"x":150,"y":103},{"x":166,"y":93}],"name":"person","color":"#1000f0"},{"points":[{"x":899,"y":259.76},{"x":927,"y":255},{"x":954,"y":263},{"x":943,"y":224},{"x":991,"y":228},{"x":985,"y":278},{"x":1005,"y":278},{"x":1024,"y":281},{"x":1024,"y":343.24},{"x":998,"y":358},{"x":989,"y":378},{"x":975,"y":379},{"x":971,"y":389},{"x":968,"y":410},{"x":955,"y":413},{"x":935,"y":386},{"x":905,"y":377},{"x":883,"y":348},{"x":878,"y":312}],"name":"bicycle","color":"#008000"},{"points":[{"x":907,"y":209.715},{"x":932.25,"y":207},{"x":955,"y":213.125},{"x":948,"y":232},{"x":952,"y":256.285},{"x":910.75,"y":255},{"x":893,"y":245.875},{"x":894,"y":226}],"name":"food basket","color":"#008000"},{"points":[{"x":67.83500000000001,"y":225},{"x":87,"y":212},{"x":116,"y":217},{"x":109,"y":250},{"x":121,"y":247},{"x":133,"y":231},{"x":153,"y":231},{"x":180,"y":240},{"x":154,"y":268},{"x":193,"y":257},{"x":211,"y":244},{"x":228.875,"y":236},{"x":230,"y":250},{"x":191,"y":278},{"x":242,"y":338},{"x":240,"y":368},{"x":202,"y":402},{"x":295,"y":367},{"x":299,"y":372.375},{"x":285,"y":391},{"x":248,"y":409},{"x":217,"y":417},{"x":239,"y":447},{"x":271,"y":500},{"x":334.165,"y":661},{"x":216.125,"y":663},{"x":189,"y":613},{"x":167,"y":558},{"x":155,"y":501},{"x":144,"y":455},{"x":118,"y":476},{"x":114,"y":465},{"x":88,"y":474.625},{"x":86,"y":464},{"x":131,"y":438},{"x":130,"y":416},{"x":119,"y":400},{"x":76,"y":407},{"x":74,"y":401},{"x":34,"y":408},{"x":29,"y":392},{"x":84,"y":389},{"x":115,"y":376},{"x":110,"y":359},{"x":92,"y":313},{"x":45,"y":320},{"x":42,"y":306},{"x":75,"y":292},{"x":67,"y":270},{"x":73,"y":250}],"name":"parked bicycles","color":"#008000"}]}
];

g_example1polys=[{"points":[{"x":824.75,"y":464.515,"tag":false},{"x":822.5,"y":437.405,"tag":false},{"x":802,"y":407.185,"tag":false},{"x":699.25,"y":410,"tag":false},{"x":673.125,"y":435.1875,"tag":false},{"x":623,"y":442.375,"tag":false},{"x":622.5,"y":471.095,"tag":false},{"x":640,"y":491.815,"tag":false},{"x":697.75,"y":493,"tag":false},{"x":801,"y":487.625,"tag":false}],"name":"SUV","color":"#ff0000",
  polygons:[{"points":[{"x":696,"y":456,"tag":false},{"x":698,"y":455,"tag":false},{"x":715,"y":458,"tag":false},{"x":721,"y":467,"tag":false},{"x":720.5,"y":480.5,"tag":false},{"x":711,"y":492,"tag":false},{"x":692.75,"y":493,"tag":false},{"x":685,"y":481,"tag":false},{"x":684,"y":466,"tag":false}],"name":"wheel","color":"#80c000"}]


},{"points":[{"x":216,"y":510,"tag":false},{"x":367,"y":503,"tag":false}],"name":"kerb edge","color":"#c08000"},{"points":[{"x":502,"y":495,"tag":false},{"x":631,"y":488,"tag":false}],"name":"kerb edge","color":"#80c000"},{"points":[{"x":839,"y":354,"tag":false},{"x":836,"y":198,"tag":false}],"name":"lamp post","color":"#0080c0"},{"points":[{"x":479,"y":377.43,"tag":false},{"x":515.75,"y":357.21500000000003,"tag":false},{"x":551.5,"y":357,"tag":false},{"x":596,"y":376.25,"tag":false},{"x":608.75,"y":416.58},{"x":598.5,"y":441.90999999999997,"tag":false},{"x":564,"y":452.57,"tag":false},{"x":515.5,"y":455,"tag":false},{"x":485,"y":442.75,"tag":false}],"name":"bush","color":"#00ff00"},{"points":[{"x":322,"y":401}],"name":"head","color":"#00c080"},{"points":[{"x":276,"y":390}],"name":"head","color":"#8000c0"},{"points":[{"x":903,"y":428}],"name":"wing mirror","color":"#c08000"}];
g_polys=[];
repaint();

</script>
</body>
</html>

