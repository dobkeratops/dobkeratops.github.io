<html>
<body>
<style>body{overflow:hidden; width:100%;height:100%}</style>
tool:
<button id="point">point</button>
<button id="line">line</button>
<button id="rect">rect</button>
<button id="poly">poly</button>
<button id="move">move</button>
<input id="currentLabel" value="car">current label</button>
<input type="checkbox" id="showLabels" checked>showLabels</input>
(hotkeys: o l r p m; [ ] toggle preset labels)
<canvas id="editor" width="1920" height="1080">
</canvas>

<script>

editor=document.getElementById("editor");
var g_presetLabels=["car","person","tree","animal","object"];
var g_presetLabelIndex=0;
var g_showLabelNames=true;
var g_mousepos={};
var g_dragstart={};
var g_drawfeedback=null;
var g_polys=[];
var g_currentPoly=[];
var g_tool;
var g_img = new window.Image();
var g_mouseDelta={};
var g_showVertices=true;
var g_labelColor="white"
g_img.src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Queen_Street_NOTL_1.jpg/1920px-Queen_Street_NOTL_1.jpg"
g_img.onload=function(){
  g_scaled_w = 1024; g_scaled_h= (g_scaled_w * g_img.height)/g_img.width;
  repaint();  
}
var g_width = editor.width;
var g_height = editor.height;
var g_scaled_w = 1024; g_scaled_h= (g_scaled_w * g_img.height)/g_img.width;

function polyFromRect(rc) {
  return {
    points:[
      {x:rc.start.x, y:rc.start.y},
      {x:rc.end.x,   y:rc.start.y},
      {x:rc.end.x,   y:rc.end.y},
      {x:rc.start.x, y:rc.end.y}
    ],
    name:rc.name
  };
}
function averagePoint(a,b){
  return {x:(a.x+b.x)/2, y:(a.y+b.y)/2}
}
function distSquared2d(a,b){
   dx=b.x-a.x; dy=b.y-a.y; return dx*dx+dy*dy;
}
g_snapRadius=5;

// any polygon points that are colinear with prev/next deemed extraneous - remove
function trimPolyPoints(poly) {
  newpoints=[];
  if (poly.points.length<3) {return;}
  num=poly.points.length;
  for (i=0; i<num; i++) {
     iprev=(i+num-1)%num;
     inext=(i+1)%num;
     pt=poly.points[i];
     midpoint=averagePoint(poly.points[iprev],poly.points[inext]);
     if (distSquared2d(midpoint,pt)>g_snapRadius*g_snapRadius){
       newpoints.push(pt);
     }
  }
  if (newpoints.length!=poly.points.length){
    poly.points=newpoints;
  }
}

function polyFromLine(v0,v1,name){
  return{
    points:[v0,v1],
    name:name
  }
}
function polyFromPoint(v0,name){
  return{
    points:[v0],
    name:name
  }
}
function fillCircle(context, x,y,r) {
  context.beginPath();
  context.arc(x, y, r, 0, 2*Math.PI);
  context.fill();
}

function drawRectOutline(context,start,end){
  context.beginPath();
  context.moveTo(start.x,start.y);
  context.lineTo(end.x,start.y);
  context.lineTo(end.x,end.y);
  context.lineTo(start.x,end.y);
  context.lineTo(start.x,start.y);
  context.stroke();
}
function dragFeedbackCrosshairFull(context){
  drawCrosshairFull(context,g_mousepos);
}
function drawPointSnapCrosshair(ctx,cursorPos){
  vt=pickPointAt(cursorPos);
  drawCrosshair(ctx,vt?vt:cursorPos,g_snapRadius*2);
  if (vt) { fillCircle(ctx,vt.x,vt.y,g_snapRadius);}
}

function dragFeedbackCrosshair(context){
  drawPointSnapCrosshair(context,g_mousepos,g_snapRadius);
}

function dragFeedbackRect(context){
    context.globalAlpha=0.5;
    context.fillStyle = "red";
    context.beginPath();
    context.moveTo(g_dragstart.x,g_dragstart.y);
    context.lineTo(g_mousepos.x,g_dragstart.y);
    context.lineTo(g_mousepos.x,g_mousepos.y);
    context.lineTo(g_dragstart.x,g_mousepos.y);
    context.closePath();
    context.fill();
}

function getSnappedRefPoint(cursor){
   vt=pickPointAt(cursor);
   return vt?vt:cursor;
}

function dragFeedbackLine(context){
    context.globalAlpha=0.75;
    context.strokeStyle = "red";
    context.beginPath();
    context.moveTo(g_dragstart.x,g_dragstart.y);
    endpoint=getSnappedRefPoint(g_mousepos);
    context.lineTo(endpoint.x,endpoint.y);
    context.stroke();
    drawPointSnapCrosshair(context,g_mousepos);
}

function pickPointAt(cursorPt) {
  vertex=null;
  minDist2=g_snapRadius*g_snapRadius;
  for (pli=0; pli<g_polys.length; pli++) {
    pl=g_polys[pli];
    for (pti=0; pti<pl.points.length; pti++) {
       d2=distSquared2d(pl.points[pti],cursorPt);
       if (d2<minDist2){
         minDist2=d2;
         vertex=pl.points[pti];    
       }  
    }
  }
  return vertex;
}

function pickOrMakePoint(cursorPt){
  vt=pickPointAt(cursorPt);
  if (vt) {return vt;}
  newpl=polyFromPoint(cursorPt,"");
  g_polys.push(newpl);
  return newpl.points[0];
}

function pickPolyFeatureAt(cursorPt){
  picked={pointIndex:-1,polyIndex:-1,edgeIndex:-1,edgeFraction:0.0,point:{}};
  minDist2=10000*10000;

  for (pli=0; pli<g_polys.length; pli++) {
    pl=g_polys[pli];

    // pick the polygon centre?
    centre=polyCentre(pl.points);
    d2=distSquared2d(centre,cursorPt);
    if (d2<minDist2 && d2<g_snapRadius*g_snapRadius){
       minDist2=d2;
       picked.edgeIndex=-1;
       picked.pointIndex=-1;
       picked.polyIndex=pli;
       picked.pickedPoint=centre;
    }
    // pick polygon Edge?
    for (pti=0; pti<pl.points.length; pti++) {
       pti1=(pti+1)%pl.points.length;
       edgeCentre=averagePoint(pl.points[pti],pl.points[pti1]);
       d2=distSquared2d(edgeCentre,cursorPt);
       if (d2<=minDist2){
         minDist2=d2;
         picked.polyIndex=pli;
         picked.edgeIndex=pti;
         picked.pointIndex=-1;
         picked.pickedPoint=edgeCentre;
       } 
    }    
    
    // pick polygon vertex?
    for (pti=0; pti<pl.points.length; pti++) {
      pt=pl.points[pti];
      d2=distSquared2d(pt,cursorPt);
      if (d2<=minDist2){
         minDist2=d2;
         picked.pointIndex=pti;
         picked.polyIndex=pli;
         picked.edgeIndex=-1;
         picked.pickedPoint=pt;
      }
    }

    
  }
  return picked;
}

function drawFeedbackPoly(context){
    if (g_currentPoly.length>0){
      context.globalAlpha=0.75;
      context.strokeStyle = "red";
      endpt=g_mousepos;
      if (distSquared2d(g_currentPoly[0],g_mousepos)<g_snapRadius*g_snapRadius) {
        endpt=g_currentPoly[0];
        context.strokeStyle = "green";
        context.globalAlpha=1.0;
      }
      context.beginPath();
      context.moveTo(g_currentPoly[0].x,g_currentPoly[0].y);
      for (i=1; i<g_currentPoly.length; i++){
        context.lineTo(g_currentPoly[i].x,g_currentPoly[i].y);
      }
      context.lineTo(endpt.x,endpt.y);
      context.stroke();
    }
    dragFeedbackCrosshair(context);
}

function polyCentre(poly){
   tx=0,ty=0;
   for (i=0; i<poly.length; i++){
     tx+=poly[i].x; ty+=poly[i].y;
   }
   return {x: tx/poly.length, y:ty/poly.length};
}

function drawFeedbackPickPolyPoint(ctx) {
  picked = g_adjustPoint?g_adjustPoint:pickPolyFeatureAt(g_mousepos);
  if (picked.polyIndex>=0) {
     pt=(picked.edgeIndex>=0)?picked.pickedPoint:(picked.pointIndex>=0)?g_polys[picked.polyIndex].points[picked.pointIndex]:picked.pickedPoint;
   
    fillCircle(ctx,pt.x,pt.y,g_snapRadius);
     
  }
}
function drawCrosshairFull(context,cursor){
  context.strokeStyle="#ffffff";
  context.globalAlpha=0.5;
  context.beginPath();
  context.moveTo(cursor.x,0);
  context.lineTo(cursor.x,1080);
  context.stroke();
  context.beginPath();
  context.moveTo(0,cursor.y);
  context.lineTo(1920,cursor.y);
  context.stroke();
}
function drawCrosshair(context,cursor,size){
  context.strokeStyle="#ffffff";
  context.globalAlpha=0.5;
  context.beginPath();
  context.moveTo(cursor.x,cursor.y-size);
  context.lineTo(cursor.x,cursor.y+size);
  context.stroke();
  context.beginPath();
  context.moveTo(cursor.x-size,cursor.y);
  context.lineTo(cursor.x+size,cursor.y);
  context.stroke();
}

function repaint() {
  g_showLabelNames=document.getElementById("showLabels").checked;
  console.log(document.getElementById("showLabels").checked);
  var canvas = document.querySelector("canvas");
  var context = canvas.getContext("2d");
 
  context.globalAlpha=1.0;
  img=g_img;
  context.drawImage(img,0,0,img.width,img.height,0,0,g_scaled_w,g_scaled_h);

  context.globalAlpha=0.5;

  context.fillStyle = "green";

  context.strokeStyle="#00ff00";
  context.font = "20px Arial";


  // Show polys
  for (pli=0; pli<g_polys.length; pli++){
    pl=g_polys[pli];
    // fill the area
    context.globalAlpha=0.5;
    if (pl.points.length>2){
      context.beginPath();
      context.moveTo(pl.points[pl.points.length-1].x,pl.points[pl.points.length-1].y);
      for (j=0; j<pl.points.length; j++) {
        context.lineTo(pl.points[j].x,pl.points[j].y);
      }
      context.closePath();
      context.fillStyle = "green";
      context.fill();
    }

    context.globalAlpha=0.75;
    if (g_showVertices){
      for (j=0; j<pl.points.length; j++) {
        fillCircle(context,pl.points[j].x,pl.points[j].y,g_snapRadius/2)
      }
    }

    // stroke the outline
    context.strokeStyle = "green";
    context.globalAlpha=0.75;
    context.beginPath();
    context.moveTo(pl.points[pl.points.length-1].x,pl.points[pl.points.length-1].y);
    for (j=0; j<pl.points.length; j++) {
      context.lineTo(pl.points[j].x,pl.points[j].y);
    }
    context.stroke();
    // draw the label name.
    context.globalAlpha=0.75;
    pos=polyCentre(pl.points);
    if (g_showLabelNames){
      var textWidth = context.measureText(pl.name).width;
      var textHeight=20.0;
      context.globalAlpha=0.25;
      context.fillStyle = "black";
      context.fillRect(pos.x-textWidth/2,pos.y-textHeight/2, textWidth, textHeight);
      context.globalAlpha=0.75;
      context.fillStyle = g_labelColor;
      context.fillText(pl.name,pos.x-textWidth/2,pos.y+textHeight/2);
    }
  }

  // show current tool feedback
  if (g_drawfeedback){
    g_drawfeedback(context);
  }

}


function getCurrentLabel(){
// get the entered label and cache it.
val= document.getElementById("currentLabel").value; g_presetLabels[g_presetLabelIndex]=val; return val;}
function setCurrentLabel(newval){document.getElementById("currentLabel").value=newval;}

function TogglePresetLabel(dir){
  next=g_presetLabelIndex+dir;
  if (next<0)next+=g_presetLabels.length;
  g_presetLabelIndex=next%g_presetLabels.length;
  setCurrentLabel(g_presetLabels[g_presetLabelIndex]);
}

g_rectTool={
  activate: function(e){
     g_drawfeedback=dragFeedbackCrosshairFull;
  },
  mousedown: function(e){
      g_drawfeedback=dragFeedbackRect;
  },
  mousemove: function(e){
  },
  mouseup:function(e){
      newrect={start:g_dragstart,end:g_mousepos,name: getCurrentLabel()};
    
      if (distSquared2d(g_dragstart,g_mousepos)>0){
        g_polys.push(polyFromRect(newrect));
      }
      g_drawfeedback=dragFeedbackCrosshairFull;
  }
};

g_lineTool={
  name:"draw edges",
  activate: function(e){
     g_drawfeedback=dragFeedbackCrosshair;
  },

  mousedown: function(e){
      g_drawfeedback=dragFeedbackLine;
  },
  mouseup:function(e){
      
      newline={start:g_dragstart,end:g_mousepos};
      if (distSquared2d(g_dragstart,g_mousepos)>0){
        vstart=pickOrMakePoint(g_dragstart);
        vend=pickOrMakePoint(g_mousepos);
        g_polys.push({points:[vstart,vend], name:getCurrentLabel()});
      }
      g_drawfeedback=dragFeedbackCrosshair;
  }
};

g_polyTool={
  name:"draw polygon",
  activate: function(e){
     g_drawfeedback=dragFeedbackCrosshair;
  },

  mousedown: function(e){
      g_drawfeedback=drawFeedbackPoly;
      console.log("add poly point");
      if (g_currentPoly.length>2){
        if (distSquared2d(g_mousepos,g_currentPoly[0])<g_snapRadius*g_snapRadius){
          console.log("finish poly");
          g_polys.push({points:g_currentPoly,name:getCurrentLabel()});
          g_currentPoly=[];
          return;
        }
      }
      g_currentPoly.push(g_mousepos);

  },
  mouseup:function(e){
  }
};
g_adjustPoint=null;

g_pointTool={
  name:"draw points",
  activate:function(e){
    g_adjustPoint=null;
    g_drawfeedback=dragFeedbackCrosshair;
  },
  mousedown: function(e){
      console.log("add  point");
      g_polys.push(polyFromPoint(g_mousepos,getCurrentLabel()));
  },
  mouseup: function(e){
  },
  mousemove: function(e){
  }
};

g_moveTool={
  name:"move vertices/edgesplit",
  activate:function(e){
    g_drawfeedback=drawFeedbackPickPolyPoint;
  },
  mousemove: function(e){
    if (g_adjustPoint){

      // edge split operation?
      if (g_adjustPoint.edgeIndex>=0){
        console.log("move tool-split edge.");
        pl=g_polys[g_adjustPoint.polyIndex];
        pti1=(g_adjustPoint.edgeIndex+1)%pl.points.length;
        newPt=averagePoint(pl.points[g_adjustPoint.edgeIndex],pl.points[pti1]);
        newPt=g_mousepos;

        // 2 types of edgeplit, if the poly is just an edge, make 2 polys with new vertex
        // else split in the boundary
        if (g_polys[g_adjustPoint.polyIndex].points.length==2){
          splitpoly=g_polys[g_adjustPoint.polyIndex];
          midpointobj=polyFromPoint(newPt,splitpoly.name);
          g_polys.push( midpointobj);
          g_polys.push( polyFromLine(midpointobj.points[0],splitpoly.points[1], splitpoly.name));
          splitpoly.points[1]=midpointobj.points[0];
          g_adjustPoint.pointIndex=1;
          g_adjustPoint.edgeIndex=-1;
        } else{
           //true poly split.
          g_polys[g_adjustPoint.polyIndex].points.splice(g_adjustPoint.edgeIndex+1,0,newPt);
         // re-pick the poly
 //       g_adjustPoint=pickPolyFeatureAt(g_mousepos);

          g_adjustPoint.pointIndex=g_adjustPoint.edgeIndex+1;
          g_adjustPoint.edgeIndex=-1;
        }

      }


      pl=g_polys[g_adjustPoint.polyIndex];
      if (g_adjustPoint.pointIndex>=0 ){
        //move a vertex..
        pl.points[g_adjustPoint.pointIndex].x+=g_mouseDelta.x;
        pl.points[g_adjustPoint.pointIndex].y+=g_mouseDelta.y;
      } else if (g_adjustPoint.edgeIndex<0 && g_adjustPoint.pointIndex<0) {
        // move the whole poly..
        for (pti=0; pti<pl.points.length;pti++){
          pl.points[pti].x+=g_mouseDelta.x;
          pl.points[pti].y+=g_mouseDelta.y;
        }
      }
    }
  },
  mousedown: function(e){
    pick=pickPolyFeatureAt(g_mousepos);
    if (pick.polyIndex>=0){
      g_adjustPoint=pick;
      if (pick.pointIndex>=0){
        console.log("move point..");
      }

    }
  },
  mouseup: function(e){
    g_adjustPoint=null;
  }
};

g_tool=g_rectTool;

function SetTool(tool){
  if (g_tool){
    if (g_tool.deactivate){
      g_tool.deactivate();
    }
  }
  g_tool=tool;
  if (tool.activate){
    tool.activate();
  }
}

// todo create these+buttons programatically
document.getElementById("poly").onclick=function(){SetTool(g_polyTool);};
document.getElementById("line").onclick=function(){SetTool(g_lineTool);};
document.getElementById("point").onclick=function(){SetTool(g_pointTool);};
document.getElementById("rect").onclick=function(){SetTool(g_rectTool);};
document.getElementById("move").onclick=function(){SetTool(g_moveTool);};

function readMousePos(e){
  var edrect = editor.getBoundingClientRect();

  opos=g_mousepos;g_mousepos={x:e.clientX-edrect.left,y:e.clientY-edrect.top}; g_mouseDelta.x=g_mousepos.x-opos.x; g_mouseDelta.y=g_mousepos.y-opos.y;}
editor.addEventListener('mousemove',function(e){
  readMousePos(e);
  if (g_tool.mousemove) {g_tool.mousemove(e);}
  repaint();
});

editor.addEventListener('mousedown', function(e){readMousePos(e);g_dragstart=g_mousepos;g_tool.mousedown(e); repaint();});
editor.addEventListener('mouseup',   function(e){readMousePos(e);g_tool.mouseup(e);repaint();});
window.addEventListener('keydown',  function(e){
  kc=e.keyCode;
  console.log("keypress:"+kc);
  // todo - programatic, show hotkeys.
  if (kc==82){SelectTool(g_rectTool)} 
  else if (kc==77){SetTool(g_moveTool)}
  else if (kc==80){SetTool(g_polyTool)}
  else if (kc==79){SetTool(g_pointTool)}
  else if (kc==76){SetTool(g_lineTool)}
  else if (kc==221){TogglePresetLabel(1);}
  else if (kc==219){TogglePresetLabel(-1);}
  readMousePos(e);repaint();
},false);

repaint();

</script>
</body>
</html>

