canvas example<div>
<canvas id="myCanvas" width="512" height="512"></canvas>
<script>

function debug(x){	alert(JSON.stringify(x));};

// mini vector maths lib
//construct a vec3
function vec3(x,y,z){return {x:x,y:y,z:z}}
function vadd(a,b){return {x: a.x+b.x, y:a.y+b.y, z:a.z+b.z};}
function vsub(a,b){return {x: a.x-b.x, y:a.y-b.y, z:a.z-b.z};}
// just add 3 vectors together. a+b+c+d
function vsum3(a,b,c){return vadd(vadd(a,b),c);}

// just add 4 vectors together. a+b+c+d
function vsum4(a,b,c,d){return vadd(vadd(a,b),vadd(c,d));}
// dot product = cos(angle between a,b)*length(a)*length(b)
function vdot(a,b){return a.x*b.x+a.y*b.y+a.z*b.z;}
// scale a vector by a factor 'f'
function vscale(a,f){return {x:a.x*f,y:a.y*f, z:a.z*f}}
// "multiply-accumulate" vector = a+b*f
function vmacc(a,b,f){return {x:a.x+b.x*f, y:a.y+b.y*f,z:a.z+b.z*f}}
// linear interpolation between 2 vectors
function vlerp(a,b,f){return vmacc(a,vsub(b,a),f);}

// 'cross product' - creates a vector perpendicular to the 2 input vectors
function vcross(a,b){return {x:a.y*b.z-a.z*b.y, y:a.z*b.x-a.x*b.z, z:a.x*b.y-a.y*b.x};}
// make a unit vector out of a given vector
function vnormalize(a){return vscale(a,1.0/sqrt(vdot(a,a)));}

// draw a line taking vectors as vertices
function drawLine(ctx,a,b){ ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();}

// draw a wireframe mesh
function drawMesh(ctx,msh,matrix){
	// transform the vertices by the matrix 'm'
	// the matrix could be rotation,translation, scaling or any combination
	var transformedVertices=msh.vertices.map(v=>matrix43MulVec3w1(matrix,v));
	// step through each edge and draw it by looking up its vertices
	for (var i=0; i<msh.edges.length; i++) {
		edge=msh.edges[i];
		drawLine(ctx,transformedVertices[edge.s],transformedVertices[edge.e]);
	}
}

// construct a '4x3 matrix' - can describe 'affine transformations'
// i.e. any combinatio of rotation,scaling,sheer,translation
// '4x3' holds new basis vectors ax,ay,az, and new centre 'aw' (prefix 'a', 'w axis'.. the columns are labelled 'ax,ay,az,aw' in sequence)
// sometimes i call the last element 'pos' but thats less general.
// when you later move to 4x4 matrices ,
// the 'w' components include information about perspective
// i write 43 instead of 4x3 because its easier to type.
// for 3d graphics matrices are small - 3x3, 4x3, 4x4. 
// often people just use 4x4 padded with zeros.
function matrix43(vx,vy,vz,vw){return {ax:vx,ay:vy,az:vz,aw:vw};}

// transform a POINT vector 'v' by a 4x3 matrix 'm' - this can apply rotation,scaling,sheer,translation
// this is matrix x vector multiplied, implemented by treating the matrix
// as a collection of new basis vectors, to be scaled by the input vector and summed
// to make the output vector.
// for 4x3 matrices, the 'aw' is scaled by an implicit 1.0 , as if vec3 is actually
// vec4(x,y,z,1.0) 
// sometimes later we will use 4 element vectors , with 'w'=1.0 or 0.0 to distinguish points vs offsets
function matrix43MulVec3w1(m,v){
	return vsum4(	m.aw,
			vscale(m.ax,v.x),
			vscale(m.ay,v.y),
			vscale(m.az,v.z));
}

// transform an OFFSET vector by a 4x3 matrix, 
// i.e. ignore the matrix' 'aw'(position,4th column) - i.e. 
// treating this as vec4(x,y,z,0.0)
// sometimes later we will use 4 element vectors , with 'w'=1.0 or 0.0 to distinguish points vs offsets
function matrix43MulVec3w0(m,v){
	return vsum3(	vscale(m.ax,v.x),
			vscale(m.ay,v.y),
			vscale(m.az,v.z));
}
// combine 2 4x3 transformation matrices - matrix mul matrix
// implemented by tranforming the vector components of the matrix
// the AXES are treated as (x,y,z,0). the POSITION (aw) is treated as (x,y,z,1)
// i.e equiv to a 4x4 matrix padded out with (0,0,0,1) for the last row
function matrix43MulMatrix43(first,second){
	return matrix43(
		matrix43MulVec3w0(first, second.ax),
		matrix43MulVec3w0(first, second.ay),
		matrix43MulVec3w0(first, second.az),
		matrix43MulVec3w1(first, second.aw),
		);
}



function matrix43RotateZ(ang){
	var c=Math.cos(ang),s=Math.sin(ang);
	return matrix43(vec3(c,s,0.0), vec3(-s,c,0.0), vec3(0.0,0.0,1.0), vec3(0.0,0.0,0.0));
}
function matrix43ScaleXYZ(sx,sy,sz){
	return matrix43(vec3(sx,0.0,0.0), vec3(0.0,sy,0.0), vec3(0.0,0.0,sz), vec3(0.0,0.0,0.0));
}

var c=document.getElementById("myCanvas");
var ctx=c.getContext("2d");

// create an example mesh , just a square
var msh={
	vertices:[vec3(-10,-10,0),vec3(10,-10,0),vec3(-10,10,0), vec3(10,10,0)],
	edges:[{s:0,e:1}, {s:2,e:3},{s:0,e:2},{s:1,e:3} ]
	};

// draw the square at 10 random rotations,scalings & positoins..
for (var i=0; i<10; i++) {
	// make a random rotation matrix, 
	var mr=matrix43RotateZ(Math.random()*6.248);
	// make a random scaling matrix,
	var ms=matrix43ScaleXYZ(Math.random()*5.0,Math.random()*5.0,Math.random()*5.0);

	// make a combined scaling,rotation by mutliply..
	var m=matrix43MulMatrix43(mr,ms);
	// add a translation to the matrix by overwriting 4th column, 'az'
	// easier later to do this by combining matrices
	m.aw=vec3(Math.random()*500.0,Math.random()*500.0,Math.random()*500.0);
	// finally draw the square 'msh' at the place defined by the matrix 'm'
	drawMesh(ctx,msh, m);
}

</script>
